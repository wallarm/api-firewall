{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Open Source API Firewall by Wallarm","text":"<p>API Firewall is a high-performance proxy with API request and response validation based on OpenAPI and GraphQL schemas. It is designed to protect REST and GraphQL API endpoints in cloud-native environments. API Firewall provides API hardening with the use of a positive security model allowing calls that match a predefined API specification for requests and responses, while rejecting everything else.</p> <p>The key features of API Firewall are:</p> <ul> <li> <p>Secure REST and GraphQL API endpoints by blocking malicious requests</p> </li> <li> <p>Stop API data breaches by blocking malformed API responses</p> </li> <li> <p>Discover Shadow API endpoints</p> </li> <li> <p>Validate JWT access tokens for OAuth 2.0 protocol-based authentication</p> </li> <li> <p>Denylist compromised API tokens, keys, and Cookies</p> </li> <li> <p>AllowIPList - Restrict access to endpoints by defining a list of allowed IP addresses</p> </li> <li> <p>Wide Range Attacks Protection: The API Firewall supports ModSecurity Rules and OWASP ModSecurity Core Rule Set</p> </li> </ul> <p>The product is open source, available at DockerHub and already got 1 billion (!!!) pulls. To support this project, you can star the repository.</p>"},{"location":"#operating-modes","title":"Operating modes","text":"<p>Wallarm API Firewall offers several operating modes:</p> <ul> <li> <p><code>PROXY</code>: validates HTTP requests and responses against OpenAPI 3.0 and proxies matching requests to the backend.</p> </li> <li> <p><code>API</code>: validates individual requests against OpenAPI 3.0 without further proxying.</p> </li> <li> <p><code>graphql</code>: validates HTTP and WebSocket requests against GraphQL schema and proxies matching requests to the backend.</p> </li> </ul>"},{"location":"#use-cases","title":"Use cases","text":""},{"location":"#running-in-blocking-mode","title":"Running in blocking mode","text":"<ul> <li> <p>Block malicious requests that do not match the specification</p> </li> <li> <p>Block malformed API responses to stop data breaches and sensitive information exposure</p> </li> </ul>"},{"location":"#running-in-monitoring-mode","title":"Running in monitoring mode","text":"<ul> <li> <p>Discover Shadow APIs and undocumented API endpoints</p> </li> <li> <p>Log malformed requests and responses that do not match the specification</p> </li> </ul>"},{"location":"#api-schema-validation-and-positive-security-model","title":"API schema validation and positive security model","text":"<p>When starting API Firewall, you should provide the REST or GraphQL API specification of the application to be protected with API Firewall. The started API Firewall will operate as a reverse proxy and validate whether requests and responses match the schema defined in the specification.</p> <p>The traffic that does not match the schema will be logged using the <code>STDOUT</code> and <code>STDERR</code> Docker services or blocked (depending on the configured API Firewall operation mode). When operating in the logging mode on REST API, API Firewall also logs so-called shadow API endpoints, those that are not covered in API specification but respond to requests (except for endpoints returning the code <code>404</code>).</p> <p></p> <p>By allowing you to set the traffic requirements with the API specification, API Firewall relies on a positive security model.</p>"},{"location":"#technical-data","title":"Technical data","text":"<p>API Firewall works as a reverse proxy with a built-in OpenAPI 3.0 or GraphQL request and response validator. It is written in Golang and using fasthttp proxy. The project is optimized for extreme performance and near-zero added latency.</p> <p>During the processing of incoming requests, the API Firewall recognizes a range of <code>Content-Type</code> header values, including:</p> <ul> <li> <p><code>application/json</code></p> </li> <li> <p><code>application/xml</code></p> </li> <li> <p><code>application/octet-stream</code></p> </li> <li> <p><code>application/x-www-form-urlencoded</code></p> </li> <li> <p><code>application/x-yaml</code></p> </li> <li> <p><code>application/yaml</code></p> </li> <li> <p><code>application/zip</code></p> </li> <li> <p><code>multipart/form-data</code></p> </li> <li> <p><code>text/csv</code></p> </li> <li> <p><code>text/plain</code></p> </li> <li> <p><code>+json</code> structured syntax suffixes</p> </li> <li> <p><code>+xml</code> structured syntax suffixes</p> </li> <li> <p><code>+yaml</code> structured syntax suffixes</p> </li> <li> <p><code>+csv</code> structured syntax suffixes</p> </li> </ul>"},{"location":"#starting-api-firewall","title":"Starting API Firewall","text":"<p>To download, install, and start API Firewall on Docker, refer to:</p> <ul> <li> <p>REST API guide</p> </li> <li> <p>GraphQL API guide</p> </li> </ul>"},{"location":"#demos","title":"Demos","text":"<p>You can try API Firewall by running the demo environment that deploys an example application protected with API Firewall. There are two available demo environments:</p> <ul> <li> <p>API Firewall demo with Docker Compose</p> </li> <li> <p>API Firewall demo with Kubernetes</p> </li> </ul>"},{"location":"#wallarms-blog-articles-related-to-api-firewall","title":"Wallarm's blog articles related to API Firewall","text":"<ul> <li> <p>Discovering Shadow APIs with API Firewall</p> </li> <li> <p>Wallarm API Firewall outperforms NGINX in a production environment</p> </li> <li> <p>Securing REST APIs for free with OSS APIFW</p> </li> </ul>"},{"location":"#performance","title":"Performance","text":"<p>When creating API Firewall, we prioritized speed and efficiency to ensure that our customers would have the fastest APIs possible. Our latest tests demonstrate that the average time required for API Firewall to process one request is 1.339 ms which is 66% faster than Nginx:</p> <pre><code>API Firewall 0.6.2 with JSON validation\n\n$ ab -c 200 -n 10000 -p ./large.json -T application/json http://127.0.0.1:8282/test/signup\n\nRequests per second:    13005.81 [#/sec] (mean)\nTime per request:       15.378 [ms] (mean)\nTime per request:       0.077 [ms] (mean, across all concurrent requests)\n\nNGINX 1.18.0 without JSON validation\n\n$ ab -c 200 -n 10000 -p ./large.json -T application/json http://127.0.0.1/test/signup\n\nRequests per second:    7887.76 [#/sec] (mean)\nTime per request:       25.356 [ms] (mean)\nTime per request:       0.127 [ms] (mean, across all concurrent requests)\n</code></pre> <p>These performance results are not the only ones we have got during API Firewall testing. Other results along with the methods used to improve API Firewall performance are described in this Wallarm's blog article.</p>"},{"location":"release-notes/","title":"API Firewall Changelog","text":"<p>This page describes new releases of Wallarm API Firewall.</p>"},{"location":"release-notes/#v093-2025-08-15","title":"v0.9.3 (2025-08-15)","text":"<ul> <li> <p>Added support for images with the following MIME types: image/png, image/jpeg, image/gif, image/webp, image/avif, image/heic, image/heif, image/bmp, image/tiff, image/svg+xml</p> </li> <li> <p>Bump up Go version to 1.24</p> </li> </ul>"},{"location":"release-notes/#v092-2025-06-09","title":"v0.9.2 (2025-06-09)","text":"<ul> <li> <p>Added support for Prometheus metrics in <code>API</code> mode</p> </li> <li> <p>Added parameters to configure request and response validation in line with ModSecurity rules (#127 PR):</p> <ul> <li>The <code>APIFW_MODSEC_REQUEST_VALIDATION</code> environment variable with the corresponding <code>ModSecurity.RequestValidation</code> YAML configuration parameter</li> <li>The <code>APIFW_MODSEC_RESPONSE_VALIDATION</code> environment variable with the corresponding <code>ModSecurity.ResponseValidation</code> YAML configuration parameter</li> </ul> </li> <li> <p>Added support for the environment variables in the API Firewall package</p> </li> <li> <p>Dependency upgrade</p> </li> </ul>"},{"location":"release-notes/#v091-2025-04-23","title":"v0.9.1 (2025-04-23)","text":"<ul> <li> <p>Added the <code>APIFW_API_MODE_MAX_ERRORS_IN_RESPONSE</code> environment variable to limit the number of returned validation errors in the <code>API</code> mode</p> </li> <li> <p>Fixed the <code>related_fields_details</code> field issues in the <code>API</code> mode</p> </li> <li> <p>Dependency upgrade</p> </li> </ul>"},{"location":"release-notes/#v090-2025-04-04","title":"v0.9.0 (2025-04-04)","text":"<ul> <li> <p>Added support of the YAML configuration file</p> </li> <li> <p>Added support of the endpoint-related response actions</p> </li> <li> <p>Replaced the Logrus logging library with ZeroLog</p> </li> </ul>"},{"location":"release-notes/#v089-2025-03-28","title":"v0.8.9 (2025-03-28)","text":"<ul> <li> <p>Dependency upgrade</p> </li> <li> <p>Update the Go version up to v1.23.7</p> </li> </ul>"},{"location":"release-notes/#v088-2025-02-27","title":"v0.8.8 (2025-02-27)","text":"<ul> <li> <p>Dependency upgrade</p> </li> <li> <p>Fix schema update bug in API mode </p> </li> <li> <p>Update the Go version up to v1.23.6</p> </li> </ul>"},{"location":"release-notes/#v087-2025-02-21","title":"v0.8.7 (2025-02-21)","text":"<ul> <li> <p>Fix the high CPU load issue</p> </li> <li> <p>Update the Go version up to v1.22.12</p> </li> </ul>"},{"location":"release-notes/#v086-2024-12-20","title":"v0.8.6 (2024-12-20)","text":"<ul> <li> <p>Dependency upgrade</p> </li> <li> <p>Make the release binaries version detectable by Syft</p> </li> </ul>"},{"location":"release-notes/#v085-2024-12-13","title":"v0.8.5 (2024-12-13)","text":"<ul> <li> <p>Dependency upgrade</p> </li> <li> <p>Bump Go version to 1.22.10</p> </li> </ul>"},{"location":"release-notes/#v084-2024-11-12","title":"v0.8.4 (2024-11-12)","text":"<ul> <li> <p>Fixed the DNS resolver issue in the GraphQL mode</p> </li> <li> <p>Updated the Helm chart</p> </li> <li> <p>Bump Go version to 1.22.9</p> </li> </ul>"},{"location":"release-notes/#v083-2024-10-22","title":"v0.8.3 (2024-10-22)","text":"<ul> <li> <p>Add additional API-Firewall server configuration parameters</p> </li> <li> <p>Bump Go version to 1.22.8</p> </li> </ul>"},{"location":"release-notes/#v082-2024-09-24","title":"v0.8.2 (2024-09-24)","text":"<ul> <li>Fixed DNS resolver cache issue</li> </ul>"},{"location":"release-notes/#v081-2024-09-13","title":"v0.8.1 (2024-09-13)","text":"<ul> <li> <p>Fixed incorrect request to get API specification structure issue</p> </li> <li> <p>Dependency upgrade</p> </li> <li> <p>Bump Go version to 1.22.7</p> </li> </ul>"},{"location":"release-notes/#v080-2024-08-19","title":"v0.8.0 (2024-08-19)","text":"<ul> <li> <p>Added DNS cache update feature</p> <p>Allows making asynchronous DNS requests and cache results for a configured period of time. This could be useful when DNS load balancing is used.</p> </li> <li> <p>Fixed GQL proxying configuration issue</p> </li> <li> <p>Dependency upgrade</p> </li> </ul>"},{"location":"release-notes/#v074-2024-07-12","title":"v0.7.4 (2024-07-12)","text":"<ul> <li> <p>Added <code>APIFW_API_SPECS_CUSTOM_HEADER_NAME</code> and <code>APIFW_API_SPECS_CUSTOM_HEADER_VALUE</code> environment variables. These allow adding a custom header to requests for your OpenAPI specification URL (defined in <code>APIFW_API_SPECS</code>).</p> <p>For example, this can be used to specify the authentication data for API Firewall to reach the specification URL.</p> </li> <li> <p>Added the <code>APIFW_SPECIFICATION_UPDATE_PERIOD</code> environment variable to specify the interval for updating the OpenAPI specification from the hosted URL (defined in <code>APIFW_API_SPECS</code>).</p> </li> <li> <p>Bump Alpine version to 3.20</p> </li> <li> <p>Bump Go version to 1.21.12</p> </li> </ul>"},{"location":"release-notes/#v073-2024-06-06","title":"v0.7.3 (2024-06-06)","text":"<ul> <li> <p>Dependency upgrade</p> </li> <li> <p>Supported new interface for the <code>api</code> mode usage, only for internal use</p> </li> <li> <p>Added the <code>APIFW_SERVER_REQUEST_HOST_HEADER</code> environment variable to set a custom <code>Host</code> header for requests forwarded to your backend after API Firewall validation</p> <p>This variable is supported in the <code>PROXY</code> and <code>graphql</code> API Firewall modes.</p> </li> </ul>"},{"location":"release-notes/#v072-2024-04-16","title":"v0.7.2 (2024-04-16)","text":"<ul> <li> <p>Added the demo for running the API Firewall with OWASP CoreRuleSet v4.1.0.</p> </li> <li> <p>Fixed multiple entries in <code>related_fields</code> in the <code>api</code> mode.</p> </li> <li> <p>Moved logging of errors caused by requests not matching the uploaded specification from the <code>ERROR</code> level to the <code>DEBUG</code> level. Now, <code>ERROR</code> level logs only include issues directly related to API Firewall operations. This change applies exclusively to <code>api</code> mode.</p> </li> </ul>"},{"location":"release-notes/#v071-2024-04-15","title":"v0.7.1 (2024-04-15)","text":"<ul> <li> <p>Bug fixes in the <code>api</code> mode</p> </li> <li> <p>Updated router</p> </li> <li> <p>Supported parsing of <code>Content-Type</code> headers with the <code>+json</code>, <code>+xml</code>, <code>+yaml</code>, <code>+csv</code> structured syntax suffixes</p> </li> </ul>"},{"location":"release-notes/#v070-2024-04-03","title":"v0.7.0 (2024-04-03)","text":"<ul> <li> <p>Added ModSecurity rules support (based on the Coraza project)</p> </li> <li> <p>Fixed processing issues for the requests with the OPTIONS method</p> </li> <li> <p>Added additional info to the log message of the Shadow API module</p> </li> </ul>"},{"location":"release-notes/#v0617-2024-03-28","title":"v0.6.17 (2024-03-28)","text":"<ul> <li> <p>Added IP allowlisting support in the <code>API</code> mode</p> </li> <li> <p>\u200b\u200bAdded support for subnets in allowlisted IP file and IP address validation during the file upload</p> </li> <li> <p>Added support for a new SQLite database structure (V2) in the <code>API</code> mode of the API Firewall. This version adds a <code>status</code> field to track specifications as <code>new</code> (unprocessed by the firewall) or <code>applied</code> (processed).</p> <p>For backward compatibility, the <code>APIFW_API_MODE_DB_VERSION</code> environment variable has been added - it defaults to attempting to parse the database as V2; if unsuccessful, it falls back to previous format  (V1).</p> </li> <li> <p>Added the following default response from the API Firewall to GraphQL requests that do not match a provided API schema:</p> <pre><code>{\n  \"errors\": [\n    {\n      \"message\":\"invalid query\"\n    }\n  ]\n}\n</code></pre> </li> <li> <p>Introduced the new environment variable to limit the number of queries that can be batched together in a single GraphQL request, <code>APIFW_GRAPHQL_BATCH_QUERY_LIMIT</code></p> </li> <li> <p>Upgraded Go up to 1.21 and some other dependencies</p> </li> </ul>"},{"location":"release-notes/#v0616-2024-02-27","title":"v0.6.16 (2024-02-27)","text":"<ul> <li> <p>Added IP allowlisting, enabling secure access to backends by allowing only requests from predefined IP addresses for both REST and GraphQL APIs. This update ensures requests from allowlisted IPs are validated against the OpenAPI specification 3.0, with non-allowlisted IP requests being rejected with a 403 error code. Thanks for PR #76 contributors. Read more</p> </li> <li> <p>Fixed the processing issues of the HEAD request type in the <code>api</code> mode</p> </li> <li> <p>Improved log messages by adding <code>host</code> and <code>path</code> parameters, providing immediate insight into request destinations. Issue #78</p> </li> <li> <p>Adjusted TEXT log formatting to remove multi-line outputs. All log messages in TEXT logging mode are now formatted in a single line, enhancing readability for log parsers. For example, previously, multi-line outputs were consolidated into a single line, replacing occurrences of <code>\\r\\n</code> with spaces. Issue #79</p> </li> <li> <p>Implemented a solution to generate unique <code>request_id</code> values, resolving conflicts caused by the incremental nature of <code>request_id</code>. Issue #80</p> </li> <li> <p>Add tests</p> </li> <li> <p>Dependency upgrade</p> </li> </ul>"},{"location":"release-notes/#v0615-2023-12-21","title":"v0.6.15 (2023-12-21)","text":"<ul> <li> <p>Dependency upgrade</p> </li> <li> <p>Bug fixes</p> </li> <li> <p>Add tests</p> </li> <li> <p>When operating in the <code>api</code> mode, the API Firewall now returns error messages in responses for requests containing parameter values that exceed the minimum and maximum limits defined in the OpenAPI specification</p> </li> </ul>"},{"location":"release-notes/#v0614-2023-11-23","title":"v0.6.14 (2023-11-23)","text":"<ul> <li> <p>Introduced new environment variables to limit GraphQL queries: <code>APIFW_GRAPHQL_MAX_ALIASES_NUM</code> and <code>APIFW_GRAPHQL_FIELD_DUPLICATION</code>.</p> </li> <li> <p>Implemented more detailed responses for requests that do not match mounted specifications in the API non-proxy mode.</p> </li> </ul>"},{"location":"release-notes/#v0613-2023-09-08","title":"v0.6.13 (2023-09-08)","text":"<ul> <li>Support for GraphQL API requests validation</li> </ul>"},{"location":"release-notes/#v0612-2023-08-04","title":"v0.6.12 (2023-08-04)","text":"<ul> <li> <p>Ability to set the general API Firewall mode using the <code>APIFW_MODE</code> environment variable. The default value is <code>PROXY</code>. When set to API, you can validate individual API requests based on a provided OpenAPI specification without further proxying.</p> </li> <li> <p>Introduced the ability to allow <code>OPTIONS</code> requests for endpoints specified in the OpenAPI, even if the <code>OPTIONS</code> method is not explicitly defined. This can be achieved using the <code>APIFW_PASS_OPTIONS</code> variable. The default value is <code>false</code>.</p> </li> <li> <p>Introduced a feature that allows control over whether requests should be identified as non-matching the specification if their parameters do not align with those outlined in the OpenAPI specification. It is set to <code>true</code> by default.</p> <p>This can be controlled through the <code>APIFW_SHADOW_API_UNKNOWN_PARAMETERS_DETECTION</code> variable in <code>PROXY</code> mode and via the <code>APIFW_API_MODE_UNKNOWN_PARAMETERS_DETECTION</code> variable in <code>API</code> mode.</p> </li> <li> <p>The new logging level mode <code>TRACE</code> to log incoming requests and API Firewall responses, including their content. This level can be set using the <code>APIFW_LOG_LEVEL</code> environment variable.</p> </li> <li> <p>Dependency updates</p> </li> <li> <p>Bug fixes</p> </li> </ul>"},{"location":"release-notes/#v0611-2023-02-10","title":"v0.6.11 (2023-02-10)","text":"<ul> <li> <p>Add the <code>APIFW_SERVER_DELETE_ACCEPT_ENCODING</code> environment variable. If it is set to <code>true</code>, the <code>Accept-Encoding</code> header is deleted from proxied requests. The default value is <code>false</code>.</p> </li> <li> <p>https://github.com/wallarm/api-firewall/issues/56</p> </li> <li> <p>https://github.com/wallarm/api-firewall/issues/57</p> </li> <li> <p>Add decompression for the request body and response body</p> </li> </ul>"},{"location":"release-notes/#v0610-2022-12-15","title":"v0.6.10 (2022-12-15)","text":"<ul> <li> <p>https://github.com/wallarm/api-firewall/issues/54</p> </li> <li> <p>Update dependencies</p> </li> </ul>"},{"location":"release-notes/#v069-2022-09-12","title":"v0.6.9 (2022-09-12)","text":"<ul> <li> <p>Upgrade Go to 1.19</p> </li> <li> <p>Upgrade other dependencies</p> </li> <li> <p>Fix bugs of Shadow API detection and denylist processing</p> </li> <li> <p>Delete the <code>Apifw-Request-Id</code> header from responses returned by API Firewall</p> </li> <li> <p>Add compatibility of the Ingress object with Kubernetes 1.22</p> </li> <li> <p>Terminate logging of incoming requests matching API specification at the INFO log level</p> </li> </ul>"},{"location":"release-notes/#v068-2022-04-11","title":"v0.6.8 (2022-04-11)","text":""},{"location":"release-notes/#new-features","title":"New features","text":"<ul> <li> <p>Ability to specify the URL address of the OpenAPI 3.0 specification instead of mounting the specification file into the Docker container (via the environment variable <code>APIFW_API_SPECS</code>).</p> </li> <li> <p>Ability to use the custom <code>Content-Type</code> header when sending requests to the token introspection service (via the environment variable <code>APIFW_SERVER_OAUTH_INTROSPECTION_CONTENT_TYPE</code>).</p> </li> <li> <p>Support for the authentication token denylists.</p> </li> </ul>"},{"location":"release-notes/#v067-2022-01-25","title":"v0.6.7 (2022-01-25)","text":"<p>Wallarm API Firewall is now open source. There are the following related changes in this release:</p> <ul> <li> <p>API Firewall source code and related open source license are published</p> </li> <li> <p>GitHub workflow for binary, Helm chart and Docker image building is implemented</p> </li> </ul>"},{"location":"release-notes/#v066-2021-12-09","title":"v0.6.6 (2021-12-09)","text":""},{"location":"release-notes/#new-features_1","title":"New features","text":"<ul> <li> <p>Support for OAuth 2.0 token validation.</p> </li> <li> <p>Connection to the servers signed with the custom CA certificates and support for insecure connection flag.</p> </li> </ul>"},{"location":"release-notes/#bug-fixes","title":"Bug fixes","text":"<ul> <li>https://github.com/wallarm/api-firewall/issues/27</li> </ul>"},{"location":"release-notes/#v065-2021-10-12","title":"v0.6.5 (2021-10-12)","text":""},{"location":"release-notes/#new-features_2","title":"New features","text":"<ul> <li> <p>Configuration of the maximum number of the fasthttp clients (via the environment variable <code>APIFW_SERVER_CLIENT_POOL_CAPACITY</code>).</p> </li> <li> <p>Health checks on the 9667 port of the API Firewall container (the port can be changed via the environment variable <code>APIFW_HEALTH_HOST</code>).</p> </li> </ul> <p>Instructions on running the API Firewall with new environment variables</p>"},{"location":"release-notes/#bug-fixes_1","title":"Bug fixes","text":"<ul> <li> <p>https://github.com/wallarm/api-firewall/issues/15</p> </li> <li> <p>Some other bugs</p> </li> </ul>"},{"location":"release-notes/#v064-2021-08-18","title":"v0.6.4 (2021-08-18)","text":""},{"location":"release-notes/#new-features_3","title":"New features","text":"<ul> <li> <p>Added monitoring for Shadow API endpoints. API Firewall operating in the <code>LOG_ONLY</code> mode for both the requests and responses marks all endpoints that are not included in the specification and are returning the code different from <code>404</code> as the shadow ones. You can exclude response codes indicating shadow endpoints using the environment variable <code>APIFW_SHADOW_API_EXCLUDE_LIST</code>.</p> </li> <li> <p>Configuration of the HTTP response status code returned by API Firewall to blocked requests (via the environment variable <code>APIFW_CUSTOM_BLOCK_STATUS_CODE</code>). </p> </li> <li> <p>Ability to return the header containing the reason for the request blocking (via the environment variable <code>APIFW_ADD_VALIDATION_STATUS_HEADER</code>). This feature is experimental.</p> </li> <li> <p>Configuration of the API Firewall log format (via the environment variable <code>APIFW_LOG_FORMAT</code>).</p> </li> </ul> <p>Instructions on running the API Firewall with new environment variables</p>"},{"location":"release-notes/#optimizations","title":"Optimizations","text":"<ul> <li> <p>Optimized validation of the OpenAPI 3.0 specification due to added <code>fastjson</code> parser.</p> </li> <li> <p>Added support for fasthttp.</p> </li> </ul>"},{"location":"release-notes/#v062-2021-06-22","title":"v0.6.2 (2021-06-22)","text":"<ul> <li>The first release!</li> </ul>"},{"location":"configuration-guides/allowlist/","title":"Allowlisting IPs","text":"<p>The Wallarm API Firewall enables secure access to your backend by allowing requests exclusively from predefined IP addresses. This document provides a step-by-step guide on how to implement IP allowlisting, applicable for the REST API in both the <code>PROXY</code> and <code>API</code> modes or for GraphQL API.</p> <p>This feature ensures that only requests from allowlisted IP addresses are validated against the OpenAPI specification 3.0. Requests from non-allowlisted IPs are outright rejected, returning a 403 error code, regardless of their compliance with the OpenAPI specification.</p> <p>To allowlist IP addresses:</p> <ol> <li> <p>Prepare a file listing the IP addresses you wish to allowlist. The file format is flexible (e.g., <code>.txt</code> or <code>.db</code>), with each IP address on a separate line. For instance:</p> <pre><code>1.1.1.1\n2001:0db8:11a3:09d7:1f34:8a2e:07a0:7655\n10.1.2.0/24\n</code></pre> <p>The requests from 1.1.1.1, 2001:0db8:11a3:09d7:1f34:8a2e:07a0:7655 and 10.1.2.1-10.1.2.254 IPs will be allowed.</p> <p>Allowlist validation and supported data formats</p> <p>The API Firewall validates the content of the allowlist file during list handling.</p> <p>It supports both IPv4 and IPv6 addresses, as well as subnets.</p> </li> <li> <p>Mount the allowlist file to the API Firewall Docker container using the <code>-v</code> Docker option.</p> </li> <li> <p>Run the API Firewall container with the <code>APIFW_ALLOW_IP_FILE</code> environment variable indicating the path to the mounted allowlist file inside the container.</p> </li> <li> <p>(Optional) Pass to the container the <code>APIFW_ALLOW_IP_HEADER_NAME</code> environment variable with the name of the request header that carries the origin IP address, if necessary. By default, <code>connection.remoteAddress</code> is used (the variable value is empty).</p> </li> </ol> <p>Example <code>docker run</code> command:</p> <pre><code>docker run --rm -it --network api-firewall-network --network-alias api-firewall \\\n    -v &lt;HOST_PATH_TO_SPEC&gt;:&lt;CONTAINER_PATH_TO_SPEC&gt; -e APIFW_API_SPECS=&lt;PATH_TO_MOUNTED_SPEC&gt; \\\n    -v ./ip-allowlist.txt:/opt/ip-allowlist.txt \\\n    -e APIFW_URL=&lt;API_FIREWALL_URL&gt; -e APIFW_SERVER_URL=&lt;PROTECTED_APP_URL&gt; \\\n    -e APIFW_REQUEST_VALIDATION=&lt;REQUEST_VALIDATION_MODE&gt; -e APIFW_RESPONSE_VALIDATION=&lt;RESPONSE_VALIDATION_MODE&gt; \\\n    -e APIFW_ALLOW_IP_FILE=/opt/ip-allowlist.txt -e APIFW_ALLOW_IP_HEADER_NAME=\"X-Real-IP\" \\\n    -p 8088:8088 wallarm/api-firewall:v0.9.3\n</code></pre> Environment variable Description <code>APIFW_ALLOW_IP_FILE</code> Specifies the container path to the mounted file with allowlisted IP addresses (e.g., <code>/opt/ip-allowlist.txt</code>). <code>APIFW_ALLOW_IP_HEADER_NAME</code> Defines the request header name that contains the origin IP address. The defauls value is <code>\"\"</code> that points to using <code>connection.remoteAddress</code>."},{"location":"configuration-guides/denylist-leaked-tokens/","title":"Blocking Requests with Compromised Tokens","text":"<p>The Wallarm API Firewall provides a feature to prevent the use of leaked authentication tokens. This guide outlines how to enable this feature using the API Firewall Docker container for either REST API or GraphQL API.</p> <p>This capability relies on your supplied data regarding compromised tokens. To activate it, mount a .txt file containing these tokens to the firewall Docker container, then set the corresponding environment variable. For an in-depth look into this feature, read our blog post.</p> <p>For REST API, should any of the flagged tokens surface in a request, the API Firewall will respond using the status code specified in the <code>APIFW_CUSTOM_BLOCK_STATUS_CODE</code> environment variable. For GraphQL API, any request containing a flagged token will be blocked, even if it aligns with the mounted schema. </p> <p>To enable the denylist feature:</p> <ol> <li> <p>Draft a <code>.txt</code> file with the compromised tokens. Each token should be on a new line. Here is an example:</p> <pre><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzb21lIjoicGF5bG9hZDk5OTk5ODIifQ.CUq8iJ_LUzQMfDTvArpz6jUyK0Qyn7jZ9WCqE0xKTCA\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzb21lIjoicGF5bG9hZDk5OTk5ODMifQ.BinZ4AcJp_SQz-iFfgKOKPz_jWjEgiVTb9cS8PP4BI0\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzb21lIjoicGF5bG9hZDk5OTk5ODQifQ.j5Iea7KGm7GqjMGBuEZc2akTIoByUaQc5SSX7w_qjY8\n</code></pre> </li> <li> <p>Mount the denylist file to the firewall Docker container. For example, in your <code>docker-compose.yaml</code>, make the following modification:</p> <pre><code>...\n    volumes:\n      - &lt;HOST_PATH_TO_SPEC&gt;:&lt;CONTAINER_PATH_TO_SPEC&gt;\n+     - &lt;HOST_PATH_TO_LEAKED_TOKEN_FILE&gt;:&lt;CONTAINER_PATH_TO_LEAKED_TOKEN_FILE&gt;\n...\n</code></pre> </li> <li> <p>Input the following environment variables when initiating the Docker container:</p> </li> </ol> Environment variable Description <code>APIFW_DENYLIST_TOKENS_FILE</code> Path in the container to the mounted denylist file. Example: <code>/auth-data/tokens-denylist.txt</code>. <code>APIFW_DENYLIST_TOKENS_COOKIE_NAME</code> Name of the Cookie that carries the authentication token. <code>APIFW_DENYLIST_TOKENS_HEADER_NAME</code> Name of the Header transmitting the authentication token. If both the <code>APIFW_DENYLIST_TOKENS_COOKIE_NAME</code> and <code>APIFW_DENYLIST_TOKENS_HEADER_NAME</code> are specified, the API Firewall checks both in sequence. <code>APIFW_DENYLIST_TOKENS_TRIM_BEARER_PREFIX</code> Indicates if the <code>Bearer</code> prefix should be removed from the authentication header during comparison with the denylist. If tokens in the denylist do not have this prefix, but the authentication header does, the tokens might not be matched correctly. Accepts <code>true</code> or <code>false</code> (default)."},{"location":"configuration-guides/dns-cache-update/","title":"DNS Cache Update","text":"<p>The DNS cache update feature allows you to make asynchronous DNS requests and cache results for a configured period of time. This feature could be useful when DNS load balancing is used. </p> <p>Feature availability</p> <p>This feature and corresponding variables are supported only in the <code>PROXY</code> API Firewall mode.</p> <p>To configure the DNS cache update, use the following environment variables:</p> Environment variable Type Description <code>APIFW_DNS_CACHE</code> <code>bool</code> Turns on using async DNS resolving and caching feature.  The default value is <code>false</code>. <code>APIFW_DNS_FETCH_TIMEOUT</code> <code>time.Duration</code> TTL of the cache.  The default value is <code>1 minute</code>. <code>APIFW_DNS_LOOKUP_TIMEOUT</code> <code>time.Duration</code> Lookup timeout.  The default value is <code>1 second</code>. <code>APIFW_DNS_NAMESERVER_HOST</code> <code>string</code> Host of the custom nameserver.  By default the value is <code>\u201c\u201d</code>. In this case the configured in the system DNS server will be used. <code>APIFW_DNS_NAMESERVER_PORT</code> <code>string</code> Port of the custom nameserver.  The default value is <code>53</code>. <code>APIFW_DNS_NAMESERVER_PROTO</code> <code>string</code> Protocol to use.  Possible values are case <code>tcp</code>, <code>tcp4</code>, <code>tcp6</code>, <code>udp</code>, <code>udp4</code>, <code>udp6</code> - <code>4</code> and <code>6</code> are IPv4 and IPv6.  The default value is <code>udp</code>. <p>When the asynchronous DNS resolving and caching feature is turned on, a dedicated goroutine is started and the DNS cache is updated every fetch timeout period. If a custom nameserver is configured then it will be used by the APIFW for all requests and DNS caching system. If a host contains multiple IPs for one entry then the first entry will be used. Also, the IPv4 has higher priority than the IPv6 IPs.</p>"},{"location":"configuration-guides/endpoint-related-response/","title":"Endpoint-Related Response Actions","text":"<p>You can configure validation modes (<code>RequestValidation</code>, <code>ResponseValidation</code>) for each endpoint separately. If not set for the endpoint specifically, global value is used.</p> <p>Example of <code>apifw.yaml</code></p> <pre><code>mode: \"PROXY\"\nRequestValidation: \"BLOCK\"\nResponseValidation: \"BLOCK\"\nModSecurity:\n  RequestValidation: \"LOG_ONLY\"\n  ResponseValidation: \"LOG_ONLY\"\n...\nEndpoints:\n- Path: \"/test/endpoint1\"\n    RequestValidation: \"LOG_ONLY\"\n    ResponseValidation: \"LOG_ONLY\"\n- Path: \"/test/endpoint1/{internal_id}\"\n    Method: \"get\"\n    RequestValidation: \"LOG_ONLY\"\n    ResponseValidation: \"DISABLE\"\n</code></pre> <p>The <code>Method</code> value is optional. If the <code>Method</code> is not set then the validation modes will be applied to all methods of the endpoint.</p> <p>Example of the same configuration via environment variables:</p> <pre><code>APIFW_ENDPOINTS=/test/endpoint1|LOG_ONLY|LOG_ONLY,GET:/test/endpoint1/{internal_id}|LOG_ONLY|DISABLE\n</code></pre> <p>The format of the <code>APIFW_ENDPOINTS</code> environment variable: </p> <pre><code>[METHOD:]PATH|REQUEST_VALIDATION|RESPONSE_VALIDATION\n</code></pre>"},{"location":"configuration-guides/ssl-tls/","title":"SSL/TLS Configuration","text":"<p>This guide explains how to set environment variables for configuring SSL/TLS connections between the API Firewall and the protected application, as well as for the API Firewall server itself. Provide these variables when launching the API Firewall Docker container for REST API or GraphQL API.</p>"},{"location":"configuration-guides/ssl-tls/#secure-ssltls-connection-between-api-firewall-and-the-application","title":"Secure SSL/TLS connection between API Firewall and the application","text":"<p>To establish a secure connection between the API Firewall and the protected application's server that utilizes custom CA certificates, utilize the following environment variables:</p> <ol> <li> <p>Mount the custom CA certificate to the API Firewall container. For example, in your <code>docker-compose.yaml</code>, make the following modification:</p> <pre><code>...\n    volumes:\n      - &lt;HOST_PATH_TO_SPEC&gt;:&lt;CONTAINER_PATH_TO_SPEC&gt;\n+     - &lt;HOST_PATH_TO_CA&gt;:&lt;CONTAINER_PATH_TO_CA&gt;\n...\n</code></pre> </li> <li> <p>Provide the mounted file path using the following environment variables:</p> </li> </ol> Environment variable Description <code>APIFW_SERVER_ROOT_CA</code>(only if the <code>APIFW_SERVER_INSECURE_CONNECTION</code> value is <code>false</code>) Path inside the Docker container to the protected application server's CA certificate."},{"location":"configuration-guides/ssl-tls/#insecure-connection-between-api-firewall-and-the-application","title":"Insecure connection between API Firewall and the application","text":"<p>To set up an insecure connection (i.e., bypassing SSL/TLS verification) between the API Firewall and the protected application's server, use this environment variable:</p> Environment variable Description <code>APIFW_SERVER_INSECURE_CONNECTION</code> Determines whether the SSL/TLS certificate validation of the protected application server should be disabled. The server address is denoted in the <code>APIFW_SERVER_URL</code> variable. By default (<code>false</code>), the system attempts a secure connection using either the default CA certificate or the one specified in <code>APIFW_SERVER_ROOT_CA</code>."},{"location":"configuration-guides/ssl-tls/#ssltls-for-the-api-firewall-server","title":"SSL/TLS for the API Firewall server","text":"<p>To ensure the server running the API Firewall accepts HTTPS connections, follow the steps below:</p> <ol> <li> <p>Mount the certificate and private key directory to the API Firewall container. For example, in your <code>docker-compose.yaml</code>, make the following modification:</p> <pre><code>...\n    volumes:\n      - &lt;HOST_PATH_TO_SPEC&gt;:&lt;CONTAINER_PATH_TO_SPEC&gt;\n+     - &lt;HOST_PATH_TO_CERT_DIR&gt;:&lt;CONTAINER_PATH_TO_CERT_DIR&gt;\n...\n</code></pre> </li> <li> <p>Provide mounted file paths using the following environment variables:</p> </li> </ol> Environment variable Description <code>APIFW_TLS_CERTS_PATH</code> Path in the container to the directory where the certificate and private key for the API Firewall are mounted. <code>APIFW_TLS_CERT_FILE</code> Filename of the SSL/TLS certificate for the API Firewall, located within the <code>APIFW_TLS_CERTS_PATH</code> directory. <code>APIFW_TLS_CERT_KEY</code> Filename of the SSL/TLS private key for the API Firewall, found in the <code>APIFW_TLS_CERTS_PATH</code> directory."},{"location":"configuration-guides/system-settings/","title":"System Settings","text":"<p>To fine-tune system API Firewall settings, use the following optional environment variables or YAML parameters:</p> Environment variable YAML parameter Description <code>APIFW_READ_TIMEOUT</code> Server \u2192 <code>ReadTimeout</code> The timeout for API Firewall to read the full request (including the body) sent to the application URL. The default value is <code>5s</code>. <code>APIFW_WRITE_TIMEOUT</code> Server \u2192 <code>WriteTimeout</code> The timeout for API Firewall to return the response to the request sent to the application URL. The default value is <code>5s</code>. <code>APIFW_SERVER_MAX_CONNS_PER_HOST</code>(for <code>PROXY</code> and <code>graphql</code> modes) <code>MaxConnsPerHost</code> The maximum number of connections that API Firewall can handle simultaneously. The default value is <code>512</code>. <code>APIFW_SERVER_READ_TIMEOUT</code> (for <code>PROXY</code> and <code>graphql</code> modes) Backend \u2192 ProtectedAPI \u2192 <code>ReadTimeout</code> The timeout for API Firewall to read the full response (including the body) returned to the request by the application. The default value is <code>5s</code>. <code>APIFW_SERVER_WRITE_TIMEOUT</code> (for <code>PROXY</code> and <code>graphql</code> modes) Backend \u2192 ProtectedAPI \u2192 <code>WriteTimeout</code> The timeout for API Firewall to write the full request (including the body) to the application. The default value is <code>5s</code>. <code>APIFW_SERVER_DIAL_TIMEOUT</code> (for <code>PROXY</code> and <code>graphql</code> modes) <code>DialTimeout</code> The timeout for API Firewall to connect to the application. The default value is <code>200ms</code>. <code>APIFW_SERVER_CLIENT_POOL_CAPACITY</code> (for <code>PROXY</code> and <code>graphql</code> modes) <code>ClientPoolCapacity</code> Maximum number of the fasthttp clients. The default value is <code>1000</code>. <code>APIFW_HEALTH_HOST</code> HealthAPIHost The host of the health check service. The default value is <code>0.0.0.0:9667</code>. The liveness probe service path is <code>/v1/liveness</code> and the readiness service path is <code>/v1/readiness</code>. <code>APIFW_READ_BUFFER_SIZE</code>(for APIFW server) <code>ReadBufferSize</code> Per-connection buffer size for request reading. This also limits the maximum header size. Increase this buffer if your clients send multi-KB RequestURIs and/or multi-KB headers (for example, BIG cookies). The default value is <code>8192</code>. <code>APIFW_WRITE_BUFFER_SIZE</code>(for APIFW server) <code>WriteBufferSize</code> Per-connection buffer size for response writing.  The default value is <code>8192</code>. <code>APIFW_MAX_REQUEST_BODY_SIZE</code>(for APIFW server) <code>MaxRequestBodySize</code> Maximum request body size. The server rejects requests with bodies exceeding this limit. The default value is <code>4194304</code>. <code>APIFW_DISABLE_KEEPALIVE</code>(for APIFW server) <code>DisableKeepalive</code> Disables the keep-alive connections. The server will close all the incoming connections after sending the first response to the client if this option is set to <code>true</code>. The default value is <code>false</code>. <code>APIFW_MAX_CONNS_PER_IP</code>(for APIFW server) <code>MaxConnsPerIP</code> Maximum number of concurrent client connections allowed per IP. The default value is <code>0</code> (means \"unlimited\"). <code>APIFW_MAX_REQUESTS_PER_CONN</code>(for APIFW server) <code>MaxRequestsPerConn</code> Maximum number of requests served per connection. The server closes the connection after the last request. The <code>Connection: close</code> header is added to the last response. The default value is <code>0</code> (means \"unlimited\"). <code>APIFW_SERVER_READ_BUFFER_SIZE</code>(for HTTP client sending requests) <code>ReadBufferSize</code> Per-connection buffer size for request reading. This also limits the maximum header size. The default value is <code>8192</code>. <code>APIFW_SERVER_WRITE_BUFFER_SIZE</code>(for HTTP client sending requests) <code>WriteBufferSize</code> Per-connection buffer size for response writing.  The default value is <code>8192</code>. <code>APIFW_SERVER_MAX_RESPONSE_BODY_SIZE</code>(for HTTP client sending requests) <code>MaxResponseBodySize</code> Maximum response body size. The default value is <code>0</code> (means \"unlimited\"). <p></p> Example of <code>apifw.yaml</code> <pre><code>mode: \"PROXY\"\nRequestValidation: \"BLOCK\"\nResponseValidation: \"BLOCK\"\nModSecurity:\n  RequestValidation: \"LOG_ONLY\"\n  ResponseValidation: \"LOG_ONLY\"\nCustomBlockStatusCode: 403\nAddValidationStatusHeader: false\nAPISpecs: \"openapi.yaml\"\nAPISpecsCustomHeader:\n  Name: \"\"\n  Value: \"\"\nPassOptionsRequests: true\nSpecificationUpdatePeriod: \"0\"\nServer:\n  APIHost: \"http://0.0.0.0:8282\"\n  HealthAPIHost: \"0.0.0.0:9999\"\n  ReadTimeout: \"5s\"\n  WriteTimeout: \"5s\"\n  ReadBufferSize: 8192\n  WriteBufferSize: 8192\n  MaxRequestBodySize: 4194304\n  DisableKeepalive: false\n  MaxConnsPerIP: 0\n  MaxRequestsPerConn: 0\nDNS:\n  Nameserver:\n    Host: \"\"\n    Port: \"53\"\n    Proto: \"udp\"\n  Cache: false\n  FetchTimeout: \"1m\"\n  LookupTimeout: \"1s\"\nDenylist:\n  Tokens:\n    CookieName: \"\"\n    HeaderName: \"\"\n    TrimBearerPrefix: true\n    File: \"\"\nAllowIP:\n  File: \"\"\n  HeaderName: \"\"\nShadowAPI:\n  ExcludeList:\n    - 404\n    - 200\n  UnknownParametersDetection: false\nTLS:\n  CertsPath: \"certs\"\n  CertFile: \"localhost.crt\"\n  CertKey: \"localhost.key\"\nModSecurity:\n  ConfFiles: []\n  RulesDir: \"\"\nEndpoints: []\nBackend:\n  Oauth:\n    ValidationType: \"JWT\"\n    JWT:\n      SignatureAlgorithm: \"RS256\"\n      PubCertFile: \"\"\n      SecretKey: \"\"\n    Introspection:\n      ClientAuthBearerToken: \"\"\n      Endpoint: \"\"\n      EndpointParams: \"\"\n      TokenParamName: \"\"\n      ContentType: \"\"\n      EndpointMethod: \"GET\"\n      RefreshInterval: \"10m\"\n  ProtectedAPI:\n    URL: \"http://localhost:3000/v1/\"\n    RequestHostHeader: \"\"\n    ClientPoolCapacity: 1000\n    InsecureConnection: false\n    RootCA: \"\"\n    MaxConnsPerHost: 512\n    ReadTimeout: \"5s\"\n    WriteTimeout: \"5s\"\n    DialTimeout: \"200ms\"\n    ReadBufferSize: 8192\n    WriteBufferSize: 8192\n    MaxResponseBodySize: 0\n    DeleteAcceptEncoding: false\n</code></pre>"},{"location":"configuration-guides/validate-tokens/","title":"Validating Request Authentication Tokens","text":"<p>When leveraging OAuth 2.0 for authentication, the API Firewall can be set up to validate access tokens before directing requests to your application server. The Firewall expects the access token in the <code>Authorization: Bearer</code> request header.</p> <p>API Firewall considers the token to be valid if the scopes defined in the specification and in the token meta information are the same. If the value of <code>APIFW_REQUEST_VALIDATION</code> is <code>BLOCK</code>, API Firewall blocks requests with invalid tokens. In the <code>LOG_ONLY</code> mode, requests with invalid tokens are only logged.</p> <p>Feature availability</p> <p>This feature is available only when running API Firewall for REST API request filtering.</p> <p>To configure the OAuth 2.0 token validation flow, use the following environment variables:</p> Environment variable Description <code>APIFW_SERVER_OAUTH_VALIDATION_TYPE</code> The type of authentication token validation:<ul><li><code>JWT</code> if using JWT for request authentication. Perform further configuration via the <code>APIFW_SERVER_OAUTH_JWT_*</code> variables.</li><li><code>INTROSPECTION</code> if using other token types that can be validated by the particular token introspection service. Perform further configuration via the <code>APIFW_SERVER_OAUTH_INTROSPECTION_*</code> variables.</li></ul> <code>APIFW_SERVER_OAUTH_JWT_SIGNATURE_ALGORITHM</code> The algorithm being used to sign JWTs: <code>RS256</code>, <code>RS384</code>, <code>RS512</code>, <code>HS256</code>, <code>HS384</code> or <code>HS512</code>.JWTs signed using the <code>ECDSA</code> algorithm cannot be validated by API Firewall. <code>APIFW_SERVER_OAUTH_JWT_PUB_CERT_FILE</code> If JWTs are signed using the RS256, RS384 or RS512 algorithm, the path to the file with the RSA public key (<code>*.pem</code>). This file must be mounted to the API Firewall Docker container. <code>APIFW_SERVER_OAUTH_JWT_SECRET_KEY</code> If JWTs are signed using the HS256, HS384 or HS512 algorithm, the secret key value being used to sign JWTs. <code>APIFW_SERVER_OAUTH_INTROSPECTION_ENDPOINT</code> Token introspection endpoint. Endpoint examples:<ul><li><code>https://www.googleapis.com/oauth2/v1/tokeninfo</code> if using Google OAuth</li><li><code>http://sample.com/restv1/introspection</code> for Gluu OAuth 2.0 tokens</li></ul> <code>APIFW_SERVER_OAUTH_INTROSPECTION_ENDPOINT_METHOD</code> The method of the requests to the token introspection endpoint. Can be <code>GET</code> or <code>POST</code>.The default value is <code>GET</code>. <code>APIFW_SERVER_OAUTH_INTROSPECTION_TOKEN_PARAM_NAME</code> The name of the parameter with the token value in the requests to the introspection endpoint. Depending on the <code>APIFW_SERVER_OAUTH_INTROSPECTION_ENDPOINT_METHOD</code> value, API Firewall automatically considers the parameter to be either the query or body parameter. <code>APIFW_SERVER_OAUTH_INTROSPECTION_CLIENT_AUTH_BEARER_TOKEN</code> The Bearer token value to authenticate the requests to the introspection endpoint. <code>APIFW_SERVER_OAUTH_INTROSPECTION_CONTENT_TYPE</code> The value of the <code>Content-Type</code> header indicating the media type of the token introspection service. The default value is <code>application/octet-stream</code>. <code>APIFW_SERVER_OAUTH_INTROSPECTION_REFRESH_INTERVAL</code> Time-to-live of cached token metadata. API Firewall caches token metadata and if getting requests with the same tokens, gets its metadata from the cache.The interval can be set in hours (<code>h</code>), minutes (<code>m</code>), seconds (<code>s</code>) or in the combined format (e.g. <code>1h10m50s</code>).The default value is <code>10m</code> (10 minutes)."},{"location":"demos/docker-compose/","title":"Wallarm API Firewall demo with Docker Compose","text":"<p>This demo deploys the application httpbin and Wallarm API Firewall as a proxy protecting httpbin API. Both applications are running in the Docker containers connected using Docker Compose.</p>"},{"location":"demos/docker-compose/#system-requirements","title":"System requirements","text":"<p>Before running this demo, please ensure your system meets the following requirements:</p> <ul> <li> <p>Docker Engine 20.x or later installed for Mac, Windows, or Linix</p> </li> <li> <p>Docker Compose installed</p> </li> <li> <p>make installed for Mac, Windows, or Linux (using suitable package-management utilities)</p> </li> </ul>"},{"location":"demos/docker-compose/#used-resources","title":"Used resources","text":"<p>The following resources are used in this demo:</p> <ul> <li> <p>httpbin Docker image</p> </li> <li> <p>API Firewall Docker image</p> </li> </ul>"},{"location":"demos/docker-compose/#demo-code-description","title":"Demo code description","text":"<p>The demo code contains the following configuration files:</p> <ul> <li> <p>The following OpenAPI 3.0 specifications located in the <code>volumes</code> directory:</p> <ul> <li><code>httpbin.json</code> is the httpbin OpenAPI 2.0 specification converted to the OpenAPI 3.0 specification format.</li> <li><code>httpbin-with-constraints.json</code> is the httpbin OpenAPI 3.0 specification with additional API restrictions added explicitly.</li> </ul> <p>Both these files will be used to test the demo deployment.</p> </li> <li> <p><code>Makefile</code> is the configuration file defining Docker routines.</p> </li> <li> <p><code>docker-compose.yml</code> is the file defining the httpbin and API Firewall Docker images configuration.</p> </li> </ul>"},{"location":"demos/docker-compose/#step-1-running-the-demo-code","title":"Step 1: Running the demo code","text":"<p>To run the demo code:</p> <ol> <li> <p>Clone the GitHub repository containing the demo code:</p> <pre><code>git clone https://github.com/wallarm/api-firewall.git\n</code></pre> </li> <li> <p>Change to the <code>demo/docker-compose</code> directory of the cloned repository:</p> <pre><code>cd api-firewall/demo/docker-compose\n</code></pre> </li> <li> <p>Run the demo code by using the following command:</p> <pre><code>make start\n</code></pre> <ul> <li>The application httpbin protected by API Firewall will be available at http://localhost:8080.</li> <li>The application httpbin unprotected by API Firewall will be available at http://localhost:8090. When testing the demo deployment, you can send requests to the unprotected application to know the difference.</li> </ul> </li> <li> <p>Proceed to the demo testing.</p> </li> </ol>"},{"location":"demos/docker-compose/#step-2-testing-the-demo-based-on-the-original-openapi-30-specification","title":"Step 2: Testing the demo based on the original OpenAPI 3.0 specification","text":"<p>By default, this demo is running with the original httpbin OpenAPI 3.0 specification. To test this demo option, you can use the following requests:</p> <ul> <li> <p>Check that API Firewall blocks requests sent to the unexposed path:</p> <pre><code>curl -sD - http://localhost:8080/unexposed/path\n</code></pre> <p>Expected response:</p> <pre><code>HTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 06:58:29 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n</code></pre> </li> <li> <p>Check that API Firewall blocks requests with string value passed in the parameter that requires integer data type:</p> <pre><code>curl -sD - http://localhost:8080/cache/arewfser\n</code></pre> <p>Expected response:</p> <pre><code>HTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 06:58:29 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n</code></pre> <p>This case demonstrates that API Firewall protects the application from Cache-Poisoned DoS attacks.</p> </li> </ul>"},{"location":"demos/docker-compose/#step-3-testing-the-demo-based-on-the-stricter-openapi-30-specification","title":"Step 3: Testing the demo based on the stricter OpenAPI 3.0 specification","text":"<p>Firstly, please update the path to the OpenAPI 3.0 specification used in the demo:</p> <ol> <li> <p>In the <code>docker-compose.yml</code> file, replace the <code>APIFW_API_SPECS</code> environment variable value with the path to the stricter OpenAPI 3.0 specification (<code>/opt/resources/httpbin-with-constraints.json</code>).</p> </li> <li> <p>Restart the demo by using the commands:</p> <pre><code>make stop\nmake start\n</code></pre> </li> </ol> <p>Then, to test this demo option, you can use the following methods:</p> <ul> <li> <p>Check that API Firewall blocks requests with the required query parameter <code>int</code> that does not match the following definition:</p> <pre><code>...\n{\n  \"in\": \"query\",\n  \"name\": \"int\",\n  \"schema\": {\n    \"type\": \"integer\",\n    \"minimum\": 10,\n    \"maximum\": 100\n  },\n  \"required\": true\n},\n...\n</code></pre> <p>Test the definition by using the following requests:</p> <pre><code># Request with missed required query parameter\ncurl -sD - http://localhost:8080/get\n\n# Expected response\nHTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 07:09:08 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n\n\n# Request with the int parameter value which is in a valid range\ncurl -sD - http://localhost:8080/get?int=15\n\n# Expected response\nHTTP/1.1 200 OK\nServer: gunicorn/19.9.0\nDate: Mon, 31 May 2021 07:09:38 GMT\nContent-Type: application/json\nContent-Length: 280\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Credentials: true\n...\n\n\n# Request with the int parameter value which is out of range\ncurl -sD - http://localhost:8080/get?int=5\n\n# Expected response\nHTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 07:09:27 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n\n\n# Request with the int parameter value which is out of range\ncurl -sD - http://localhost:8080/get?int=1000\n\n# Expected response\nHTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 07:09:53 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n\n\n# Request with the int parameter value which is out of range\n# POTENTIAL EVIL: 8-byte integer overflow can respond with stack drop\ncurl -sD - http://localhost:8080/get?int=18446744073710000001\n\n# Expected response\nHTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 07:10:04 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n</code></pre> </li> <li> <p>Check that API Firewall blocks requests with the query parameter <code>str</code> that does not match the following definition:</p> <pre><code>...\n{\n  \"in\": \"query\",\n  \"name\": \"str\",\n  \"schema\": {\n    \"type\": \"string\",\n    \"pattern\": \"^.{1,10}-\\\\d{1,10}$\"\n  }\n},\n...\n</code></pre> <p>Test the definition by using the following requests (the <code>int</code> parameter is still required):</p> <pre><code># Request with the str parameter value that does not match the defined regular expression\ncurl -sD - \"http://localhost:8080/get?int=15&amp;str=fasxxx.xxxawe-6354\"\n\n# Expected response\nHTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 07:10:42 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n\n\n# Request with the str parameter value that does not match the defined regular expression\ncurl -sD - \"http://localhost:8080/get?int=15&amp;str=faswerffa-63sss54\"\n\n# Expected response\nHTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 07:10:42 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n\n\n# Request with the str parameter value that matches the defined regular expression\ncurl -sD - http://localhost:8080/get?int=15&amp;str=ri0.2-3ur0-6354\n\n# Expected response\nHTTP/1.1 200 OK\nServer: gunicorn/19.9.0\nDate: Mon, 31 May 2021 07:11:03 GMT\nContent-Type: application/json\nContent-Length: 331\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Credentials: true\n...\n\n\n# Request with the str parameter value that does not match the defined regular expression\n# POTENTIAL EVIL: SQL Injection\ncurl -sD - 'http://localhost:8080/get?int=15&amp;str=\";SELECT%20*%20FROM%20users.credentials;\"'\n\n# Expected response\nHTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 07:12:04 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n</code></pre> </li> </ul>"},{"location":"demos/docker-compose/#step-4-stopping-the-demo-code","title":"Step 4: Stopping the demo code","text":"<p>To stop the demo deployment and clear your environment, use the command:</p> <pre><code>make stop\n</code></pre>"},{"location":"demos/kubernetes-cluster/","title":"Wallarm API Firewall demo with Kubernetes","text":"<p>This demo deploys the application httpbin and Wallarm API Firewall as a proxy protecting httpbin API. Both applications are running in the Docker containers in Kubernetes.</p>"},{"location":"demos/kubernetes-cluster/#system-requirements","title":"System requirements","text":"<p>Before running this demo, please ensure your system meets the following requirements:</p> <ul> <li> <p>Docker Engine 20.x or later installed for Mac, Windows, or Linux</p> </li> <li> <p>Docker Compose installed</p> </li> <li> <p>make installed for Mac, Windows, or Linux (using suitable package-management utilities)</p> </li> </ul> <p>Running this demo environment can be resource-intensive. Please ensure you have the following resources available:</p> <ul> <li> <p>At least 2 CPU cores</p> </li> <li> <p>At least 6GB volatile memory</p> </li> </ul>"},{"location":"demos/kubernetes-cluster/#used-resources","title":"Used resources","text":"<p>The following resources are used in this demo:</p> <ul> <li> <p>httpbin Docker image</p> </li> <li> <p>API Firewall Docker image</p> </li> </ul>"},{"location":"demos/kubernetes-cluster/#demo-code-description","title":"Demo code description","text":"<p>The demo code runs the Kubernetes cluster with deployed httpbin and API Firewall.</p> <p>To run the Kubernetes cluster, this demo uses the tool kind which allows running the K8s cluster in minutes using Docker containers as nodes. By using several abstraction layers, kind and its dependencies are packed into the Docker image which starts the Kubernetes cluster.</p> <p>The demo deployment is configured via the following directories/files:</p> <ul> <li> <p>The OpenAPI 3.0 specification for httpbin API is located in the file <code>volumes/helm/api-firewall.yaml</code> under the <code>manifest.body</code> path. Using this specification, API Firewall will validate whether requests and responses sent to the application address match the application API schema.</p> <p>This specification does not define the original API schema of httpbin. To demonstrate more transparently the API Firewall features, we have explicitly converted and complicated the original OpenAPI 2.0 schema and saved the changed specification to <code>volumes/helm/api-firewall.yaml</code> &gt; <code>manifest.body</code>.</p> </li> <li> <p><code>Makefile</code> is the configuration file defining Docker routines.</p> </li> <li> <p><code>docker-compose.yml</code> is the file defining the following configuration for running the temporary Kubernetes cluster:</p> <ul> <li>The kind node building based on <code>docker/Dockerfile</code>.</li> <li>Deployment of the DNS server providing simultaneous Kubernetes and Docker service discovery.</li> <li>Local Docker registry and the <code>dind</code> service deployment.</li> <li>httpbin and API Firewall Docker images configuration.</li> </ul> </li> </ul>"},{"location":"demos/kubernetes-cluster/#step-1-running-the-demo-code","title":"Step 1: Running the demo code","text":"<p>To run the demo code:</p> <ol> <li> <p>Clone the GitHub repository containing the demo code:</p> <pre><code>git clone https://github.com/wallarm/api-firewall.git\n</code></pre> </li> <li> <p>Change to the <code>demo/kubernetes</code> directory of the cloned repository:</p> <pre><code>cd api-firewall/demo/kubernetes\n</code></pre> </li> <li> <p>Run the demo code by using the command below. Please note that running this demo can be resource-intensive. It takes up to 3 minutes to start the demo environment.</p> <pre><code>make start\n</code></pre> <ul> <li>The application httpbin protected by API Firewall will be available at http://localhost:8080.</li> <li>The application httpbin unprotected by API Firewall will be available at http://localhost:8090. When testing the demo deployment, you can send requests to the unprotected application to know the difference.</li> </ul> </li> <li> <p>Proceed to the demo testing.</p> </li> </ol>"},{"location":"demos/kubernetes-cluster/#step-2-testing-the-demo","title":"Step 2: Testing the demo","text":"<p>Using the following request, you can test deployed API Firewall:</p> <ul> <li> <p>Check that API Firewall blocks requests sent to the unexposed path:</p> <pre><code>curl -sD - http://localhost:8080/unexposed/path\n</code></pre> <p>Expected response:</p> <pre><code>HTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 06:58:29 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n</code></pre> </li> <li> <p>Check that API Firewall blocks requests with string value passed in the parameter that requires integer data type:</p> <pre><code>curl -sD - http://localhost:8080/cache/arewfser\n</code></pre> <p>Expected response:</p> <pre><code>HTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 06:58:29 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n</code></pre> <p>This case demonstrates that API Firewall protects the application from Cache-Poisoned DoS attacks.</p> </li> <li> <p>Check that API Firewall blocks requests with the required query parameter <code>int</code> that does not match the following definition:</p> <pre><code>...\n{\n  \"in\": \"query\",\n  \"name\": \"int\",\n  \"schema\": {\n    \"type\": \"integer\",\n    \"minimum\": 10,\n    \"maximum\": 100\n  },\n  \"required\": true\n},\n...\n</code></pre> <p>Test the definition by using the following requests:</p> <pre><code># Request with missed required query parameter\ncurl -sD - http://localhost:8080/get\n\n# Expected response\nHTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 07:09:08 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n\n\n# Request with the int parameter value which is in a valid range\ncurl -sD - http://localhost:8080/get?int=15\n\n# Expected response\nHTTP/1.1 200 OK\nServer: gunicorn/19.9.0\nDate: Mon, 31 May 2021 07:09:38 GMT\nContent-Type: application/json\nContent-Length: 280\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Credentials: true\n...\n\n\n# Request with the int parameter value which is out of range\ncurl -sD - http://localhost:8080/get?int=5\n\n# Expected response\nHTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 07:09:27 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n\n\n# Request with the int parameter value which is out of range\ncurl -sD - http://localhost:8080/get?int=1000\n\n# Expected response\nHTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 07:09:53 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n\n\n# Request with the int parameter value which is out of range\n# POTENTIAL EVIL: 8-byte integer overflow can respond with stack drop\ncurl -sD - http://localhost:8080/get?int=18446744073710000001\n\n# Expected response\nHTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 07:10:04 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n</code></pre> </li> <li> <p>Check that API Firewall blocks requests with the query parameter <code>str</code> that does not match the following definition:</p> <pre><code>...\n{\n  \"in\": \"query\",\n  \"name\": \"str\",\n  \"schema\": {\n    \"type\": \"string\",\n    \"pattern\": \"^.{1,10}-\\\\d{1,10}$\"\n  }\n},\n...\n</code></pre> <p>Test the definition by using the following requests (the <code>int</code> parameter is still required):</p> <pre><code># Request with the str parameter value that does not match the defined regular expression\ncurl -sD - \"http://localhost:8080/get?int=15&amp;str=fasxxx.xxxawe-6354\"\n\n# Expected response\nHTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 07:10:42 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n\n\n# Request with the str parameter value that does not match the defined regular expression\ncurl -sD - \"http://localhost:8080/get?int=15&amp;str=faswerffa-63sss54\"\n\n# Expected response\nHTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 07:10:42 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n\n\n# Request with the str parameter value that matches the defined regular expression\ncurl -sD - http://localhost:8080/get?int=15&amp;str=ri0.2-3ur0-6354\n\n# Expected response\nHTTP/1.1 200 OK\nServer: gunicorn/19.9.0\nDate: Mon, 31 May 2021 07:11:03 GMT\nContent-Type: application/json\nContent-Length: 331\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Credentials: true\n...\n\n\n# Request with the str parameter value that does not match the defined regular expression\n# POTENTIAL EVIL: SQL Injection\ncurl -sD - 'http://localhost:8080/get?int=15&amp;str=\";SELECT%20*%20FROM%20users.credentials;\"'\n\n# Expected response\nHTTP/1.1 403 Forbidden\nDate: Mon, 31 May 2021 07:12:04 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n</code></pre> </li> </ul>"},{"location":"demos/kubernetes-cluster/#step-4-stopping-the-demo-code","title":"Step 4: Stopping the demo code","text":"<p>To stop the demo deployment and clear your environment, use the command:</p> <pre><code>make stop\n</code></pre>"},{"location":"demos/owasp-coreruleset/","title":"API Firewall demo with OWASP Core Rule Set v4.x.x","text":"<p>This demo deploys httpbin and Wallarm API Firewall as a proxy protecting httpbin API from general attacks using the OWASP ModSecurity Core Rule Set (CRS) v4.x.x. Both applications are running in the Docker containers connected using Docker Compose.</p>"},{"location":"demos/owasp-coreruleset/#system-requirements","title":"System requirements","text":"<p>Before running this demo, please ensure your system meets the following requirements:</p> <ul> <li> <p>Docker Engine 20.x or later installed for Mac, Windows, or Linix</p> </li> <li> <p>Docker Compose installed</p> </li> <li> <p>make installed for Mac, Windows, or Linux (using suitable package-management utilities)</p> </li> <li> <p>wget installed</p> </li> </ul>"},{"location":"demos/owasp-coreruleset/#used-resources","title":"Used resources","text":"<p>The following resources are used in this demo:</p> <ul> <li> <p>httpbin Docker image</p> </li> <li> <p>API Firewall Docker image</p> </li> <li> <p>OWASP ModSecurity Core Rule Set</p> </li> </ul>"},{"location":"demos/owasp-coreruleset/#demo-code-description","title":"Demo code description","text":"<p>The demo code contains the following configuration files:</p> <ul> <li> <p><code>httpbin.json</code> is the httpbin OpenAPI 2.0 specification converted to the OpenAPI 3.0 specification format.</p> </li> <li> <p>ModSecurity-related configuration files:</p> <ul> <li><code>coraza.conf</code> is the configuration file that contains recommended Coraza ModSecurity rules and parameters. It is created based on <code>resources/coraza.conf-recommended</code>. The only difference lies in the <code>SecRuleEngine</code> directive, which is set to <code>On</code> in <code>coraza.conf</code>.</li> <li><code>crs/rules/</code> is the directory with the OWASP CRS rule files (<code>*.conf</code>),</li> <li><code>crs/crs-setup.conf.example</code> is the OWASP CRS configuration file example.</li> </ul> <p>Automatically downloading files</p> <p>The <code>crs/rules</code> and <code>crs/crs-setup.conf.example</code> files will be downloaded automatically after starting the demo. Both these files will be used to test the demo deployment.</p> </li> <li> <p><code>Makefile</code> is the configuration file defining Docker routines.</p> </li> <li> <p><code>docker-compose.yml</code> is the file defining the API Firewall demo configuration.</p> </li> </ul> <p>When executed, the demo code performs the following operations automatically:</p> <ol> <li> <p>Fetches the latest OWASP CRS (v4.x.x) directly from the CoreRuleSet GitHub repository.</p> </li> <li> <p>Configures the ModSecurity engine based on the <code>coraza.conf</code> file from the API Firewall repository, which is adapted from the recommended <code>resources/coraza.conf-recommended</code>.</p> <p>By default, <code>SecRuleEngine</code> is set to <code>DetectionOnly</code>. To block malicious requests, it should be set to <code>On</code>, and the request/response blocking mode of the API Firewall (<code>APIFW_REQUEST_VALIDATION</code>) should be set to <code>BLOCK</code> as demonstrated in this demo code. This is the sole difference from the original configuration.</p> </li> <li> <p>Unpacks and mounts the OWASP CRS to the API Firewall Docker container at the <code>/opt/resources</code> directory. This setup is influenced by the specific environment variables:</p> <ul> <li><code>APIFW_MODSEC_CONF_FILES</code>: loads both the recommended configuration and the example configuration (<code>crs/crs-setup.conf.example</code>). The absolute paths for each are specified using the <code>;</code> delimiter.</li> <li><code>APIFW_MODSEC_RULES_DIR</code>: directs the API Firewall to apply specific rules from the <code>/opt/resources/crs/rules/</code> directory during request evaluation.</li> </ul> </li> </ol>"},{"location":"demos/owasp-coreruleset/#step-1-running-the-demo-code","title":"Step 1: Running the demo code","text":"<p>To run the demo code:</p> <ol> <li> <p>Clone the GitHub repository containing the demo code:</p> <pre><code>git clone https://github.com/wallarm/api-firewall.git\n</code></pre> </li> <li> <p>Change to the <code>demo/docker-compose/OWASP_CoreRuleSet</code> directory of the cloned repository:</p> <pre><code>cd api-firewall/demo/docker-compose/OWASP_CoreRuleSet\n</code></pre> </li> <li> <p>Run the demo code by using the following command:</p> <pre><code>make start\n</code></pre> <p>After the successful configuration and rules loading:</p> <ul> <li>The log message <code>The ModSecurity configuration has been loaded successfully</code> should appear.</li> <li>The application httpbin protected by API Firewall will be available at http://localhost:8080.</li> </ul> </li> <li> <p>Proceed to the demo testing.</p> </li> </ol>"},{"location":"demos/owasp-coreruleset/#step-2-testing-the-owasp-modsecurity-rules","title":"Step 2: Testing the OWASP ModSecurity rules","text":"<p>By default, this demo is running with the httpbin OpenAPI 3.0 specification and OWASP Core Rule Set v4.x.x. To test this demo option, you can use the following requests:</p> <ul> <li> <p>Check that API Firewall allows the requests that contain:</p> <pre><code>curl -sD - 'http://localhost:8080/anything?id=test'\n</code></pre> <p>Expected response:</p> <pre><code>HTTP/1.1 200 OK\nServer: gunicorn/19.9.0\nDate: Mon, 15 Apr 2024 18:28:02 GMT\nContent-Type: application/json\nContent-Length: 361\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Credentials: true\n\n{\n  \"args\": {\n    \"id\": \"test\"\n  },\n  \"data\": \"\",\n  \"files\": {},\n  \"form\": {},\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Apifw-Request-Id\": \"c8feabc1-0ae5-4506-ac14-6dd1b9c4fe86\",\n    \"Host\": \"backend:80\",\n    \"User-Agent\": \"curl/8.1.2\"\n  },\n  \"json\": null,\n  \"method\": \"GET\",\n  \"origin\": \"172.30.0.1\",\n  \"url\": \"http://backend:80/anything?id=test\"\n}\n</code></pre> </li> <li> <p>Check that API Firewall blocks requests with the malicious XSS payload:</p> <pre><code>curl -sD - 'http://localhost:8080/anything?id=&lt;svg%20onload%3Dalert%281%29&lt;%21--&amp;context=html'\n</code></pre> <p>Expected response:</p> <pre><code>HTTP/1.1 403 Forbidden\nDate: Mon, 15 Apr 2024 18:35:08 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n</code></pre> </li> <li> <p>Check that API Firewall blocks requests with the malicious SQLi payload:</p> <pre><code>curl -sD - 'http://localhost:8080/anything?id=\"+select+1'\n</code></pre> <p>Expected response:</p> <pre><code>HTTP/1.1 403 Forbidden\nDate: Mon, 15 Apr 2024 18:41:49 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 0\n</code></pre> </li> </ul> <p>These cases demonstrate that API Firewall protects the application from general types of attacks using the OWASP Core Rule Set.</p>"},{"location":"demos/owasp-coreruleset/#step-3-stopping-the-demo","title":"Step 3: Stopping the demo","text":"<p>To stop the demo deployment and clear your environment, use the commands:</p> <pre><code>make stop\nmake clean\n</code></pre>"},{"location":"include/apifw-yaml-example/","title":"Apifw yaml example","text":"<pre><code>mode: \"PROXY\"\nRequestValidation: \"BLOCK\"\nResponseValidation: \"BLOCK\"\nModSecurity:\n  RequestValidation: \"LOG_ONLY\"\n  ResponseValidation: \"LOG_ONLY\"\nCustomBlockStatusCode: 403\nAddValidationStatusHeader: false\nAPISpecs: \"openapi.yaml\"\nAPISpecsCustomHeader:\n  Name: \"\"\n  Value: \"\"\nPassOptionsRequests: true\nSpecificationUpdatePeriod: \"0\"\nServer:\n  APIHost: \"http://0.0.0.0:8282\"\n  HealthAPIHost: \"0.0.0.0:9999\"\n  ReadTimeout: \"5s\"\n  WriteTimeout: \"5s\"\n  ReadBufferSize: 8192\n  WriteBufferSize: 8192\n  MaxRequestBodySize: 4194304\n  DisableKeepalive: false\n  MaxConnsPerIP: 0\n  MaxRequestsPerConn: 0\nDNS:\n  Nameserver:\n    Host: \"\"\n    Port: \"53\"\n    Proto: \"udp\"\n  Cache: false\n  FetchTimeout: \"1m\"\n  LookupTimeout: \"1s\"\nDenylist:\n  Tokens:\n    CookieName: \"\"\n    HeaderName: \"\"\n    TrimBearerPrefix: true\n    File: \"\"\nAllowIP:\n  File: \"\"\n  HeaderName: \"\"\nShadowAPI:\n  ExcludeList:\n    - 404\n    - 200\n  UnknownParametersDetection: false\nTLS:\n  CertsPath: \"certs\"\n  CertFile: \"localhost.crt\"\n  CertKey: \"localhost.key\"\nModSecurity:\n  ConfFiles: []\n  RulesDir: \"\"\nEndpoints: []\nBackend:\n  Oauth:\n    ValidationType: \"JWT\"\n    JWT:\n      SignatureAlgorithm: \"RS256\"\n      PubCertFile: \"\"\n      SecretKey: \"\"\n    Introspection:\n      ClientAuthBearerToken: \"\"\n      Endpoint: \"\"\n      EndpointParams: \"\"\n      TokenParamName: \"\"\n      ContentType: \"\"\n      EndpointMethod: \"GET\"\n      RefreshInterval: \"10m\"\n  ProtectedAPI:\n    URL: \"http://localhost:3000/v1/\"\n    RequestHostHeader: \"\"\n    ClientPoolCapacity: 1000\n    InsecureConnection: false\n    RootCA: \"\"\n    MaxConnsPerHost: 512\n    ReadTimeout: \"5s\"\n    WriteTimeout: \"5s\"\n    DialTimeout: \"200ms\"\n    ReadBufferSize: 8192\n    WriteBufferSize: 8192\n    MaxResponseBodySize: 0\n    DeleteAcceptEncoding: false\n</code></pre>"},{"location":"installation-guides/api-mode/","title":"Validating Individual Requests Without Proxying","text":"<p>If you need to validate individual API requests based on a given OpenAPI specification without further proxying, you can utilize Wallarm API Firewall in a non-proxy mode. In this case, the solution does not validate responses.</p> <p>Feature availability</p> <p>This feature is available for the API Firewall versions 0.6.12 and later, and it is tailored for REST API.</p>"},{"location":"installation-guides/api-mode/#requirements","title":"Requirements","text":"<ul> <li> <p>Installed and configured Docker</p> </li> <li> <p>SQLite database with the table containing one or more OpenAPI 3.0 specifications. The database can be of one of the following formats:</p> SQLite database V1SQLite database V2 <ul> <li>Table name is <code>openapi_schemas</code>.</li> <li><code>schema_id</code>, integer (auto-increment) - ID of the specification.</li> <li><code>schema_version</code>, string - Specification version. You can assign any preferred version. When this field changes, API Firewall assumes the specification itself has changed and updates it accordingly.</li> <li><code>schema_format</code>, string - The specification format, can be <code>json</code> or <code>yaml</code>.</li> <li><code>schema_content</code>, string - The specification content.</li> </ul> <p>Use this format if you need to control whether a specification from the database has been handled by the API Firewall or not.</p> <ul> <li>Table name is <code>openapi_schemas</code>.</li> <li><code>schema_id</code>, integer (auto-increment) - ID of the specification.</li> <li><code>schema_version</code>, string - Specification version. You can assign any preferred version. When this field changes, API Firewall assumes the specification itself has changed and updates it accordingly.</li> <li><code>schema_format</code>, string - The specification format, can be <code>json</code> or <code>yaml</code>.</li> <li><code>schema_content</code>, string - The specification content.</li> <li> <p><code>status</code>, string - Specifies whether a specification is <code>new</code> (not yet processed) or <code>applied</code> (already processed). It is expected to be set to <code>new</code> by default.</p> <p>At startup, the API Firewall automatically updates processed specification status from <code>new</code> to <code>applied</code>.</p> <p>During the <code>APIFW_SPECIFICATION_UPDATE_PERIOD</code>, only specifications marked as <code>new</code> receive updates.</p> </li> </ul> </li> </ul>"},{"location":"installation-guides/api-mode/#running-the-api-firewall-container","title":"Running the API Firewall container","text":"<p>To use the API Firewall for request validation without further proxying, you need to mount the SQLite database containing OpenAPI 3.0 specifications to <code>/var/lib/wallarm-api/1/wallarm_api.db</code> inside the API Firewall Docker container. The path can be changed using the <code>APIFW_API_MODE_DEBUG_PATH_DB</code> variable.</p> <p>Use the following command to run the API Firewall container:</p> <pre><code>docker run --rm -it -v &lt;PATH_TO_SQLITE_DATABASE&gt;:/var/lib/wallarm-api/1/wallarm_api.db \\\n    -e APIFW_MODE=API -p 8282:8282 wallarm/api-firewall:v0.9.3\n</code></pre> <p>You can pass to the container the following variables:</p> Environment variable Description Required? <code>APIFW_MODE</code> Sets the general API Firewall mode. Possible values are <code>PROXY</code> (default), <code>graphql</code>, and <code>API</code>.The appropriate value for this case is <code>API</code>. Yes <code>APIFW_URL</code> URL for API Firewall. For example: <code>http://0.0.0.0:8088/</code>. The port value should correspond to the container port published to the host.If API Firewall listens to the HTTPS protocol, please mount the generated SSL/TLS certificate and private key to the container, and pass to the container the API Firewall SSL/TLS settings.The default value is <code>http://0.0.0.0:8282/</code>. No <code>APIFW_API_MODE_DEBUG_PATH_DB</code> Sets a path to a specification database inside the Docker container.The default value is <code>/var/lib/wallarm-api/1/wallarm_api.db</code>. No <code>APIFW_SPECIFICATION_UPDATE_PERIOD</code> Determines the frequency of fetching updates from the mounted database. If set to <code>0</code>, the update is disabled. The default value is <code>1m</code> (1 minute). No <code>APIFW_API_MODE_UNKNOWN_PARAMETERS_DETECTION</code> Determines if requests with undefined parameters, as per the specification, are blocked.When set to <code>true</code>, requests with any non-required, undefined parameters are rejected (e.g., <code>GET test?a=123&amp;b=123</code> is blocked if <code>b</code> is undefined in the <code>/test</code> endpoint specification). If set to <code>false</code>, such requests are allowed, provided they contain all required parameters.The default vaue is <code>true</code>. No <code>APIFW_PASS_OPTIONS</code> When set to <code>true</code>, the API Firewall allows <code>OPTIONS</code> requests to endpoints in the specification, even if the <code>OPTIONS</code> method is not described. The default value is <code>false</code>. No <code>APIFW_READ_TIMEOUT</code> The timeout for API Firewall to read the full request (including the body). The default value is <code>5s</code>. No <code>APIFW_WRITE_TIMEOUT</code> The timeout for API Firewall to return the response to the request. The default value is <code>5s</code>. No <code>APIFW_HEALTH_HOST</code> The host of the health check service. The default value is <code>0.0.0.0:9667</code>. The liveness probe service path is <code>/v1/liveness</code> and the readiness service path is <code>/v1/readiness</code>. No <code>APIFW_API_MODE_DB_VERSION</code> Determines the SQLite database version that the API Firewall is configured to use. Available options are:<ul><li><code>0</code> (default) - tries to load V2 (with the <code>status</code> field) first; if unsuccessful, attempts V1. On both failures, the firewall fails to start.</li><li><code>1</code> - recognize and process the database as V1 only.</li><li><code>2</code> - recognize and process the database as V2 only.</li></ul> No <code>APIFW_API_MODE_MAX_ERRORS_IN_RESPONSE</code> Limits the number of errors included in the API Firewall response for a single request validation.The default value is <code>0</code>, which means no limit is applied.Supported starting from version 0.9.1. No <code>APIFW_METRICS_ENABLED</code> Enables the built-in Prometheus metrics endpoint, which is exposed at port <code>9010</code> on the <code>/metrics</code> path by default. The default value is <code>false</code>. No <code>APIFW_METRICS_ENDPOINT_NAME</code> Defines the path at which the built-in Prometheus metrics endpoint is exposed. The default value is <code>metrics</code>. No <code>APIFW_METRICS_HOST</code> Defines the IP address and/or port for the built-in Prometheus metrics endpoint. When specifying a port, prefix it with a colon (<code>:</code>). The default value is <code>:9010</code>. No"},{"location":"installation-guides/api-mode/#evaluating-requests-against-the-specification","title":"Evaluating requests against the specification","text":"<p>When evaluating requests against the mounted specification, include the header <code>X-Wallarm-Schema-ID: &lt;schema_id&gt;</code> to indicate to API Firewall which specification should be used for validation:</p> Single specificationMultiple specifications <pre><code>curl http://0.0.0.0:8282/path -H \"X-Wallarm-Schema-ID: &lt;SCHEMA_ID&gt;\"\n</code></pre> <p>You can evaluate requests against multiple specifications simultaneously. To do this, include the relevant list of specification IDs in the <code>X-Wallarm-Schema-ID</code> header, separated by commas. For instance, to assess a request against specifications with IDs 1 and 2, use the following format:</p> <pre><code>curl http://0.0.0.0:8282/path -H \"X-Wallarm-Schema-ID: 1, 2\"\n</code></pre>"},{"location":"installation-guides/api-mode/#understanding-api-firewall-responses","title":"Understanding API Firewall responses","text":"<p>API Firewall responds with the <code>200</code> HTTP code and JSON with details on request validation:</p> Request matches the specificationRequest does not match the specificationUnable to validate a request <pre><code>{\n    \"summary\": [\n        {\n            \"schema_id\": 1,\n            \"status_code\": 200\n        }\n    ]\n}\n</code></pre> <pre><code>{\n    \"summary\": [\n        {\n            \"schema_id\":1,\n            \"status_code\":403\n        }\n    ],\n    \"errors\": [\n        {\n            \"message\":\"method and path are not found\",\n            \"code\":\"method_and_path_not_found\",\n            \"schema_id\":1\n        }\n    ]\n}\n</code></pre> <pre><code>{\n    \"summary\": [\n        {\n            \"schema_id\": 0,\n            \"status_code\": 500\n        }\n    ]\n}\n</code></pre> JSON key Description <code>summary</code> Array with a request validation summary. <code>summary.schema_id</code> The ID of the specification against which the API Firewall performed the request validation. <code>summary.status_code</code> Request validation status code. Possible values:<ul><li><code>200</code> if a request matches the specification.</li><li><code>403</code> if a request does not match the specification.</li><li><code>500</code> if it is unable to handle or validate a request.</li></ul> <code>errors</code> Array containing details about the reasons why a request does not match the specification. <code>errors.message</code> Explanation for the request's dismatch with the specification. <code>errors.code</code> Code indicating the reason for a request's mismatch with the specification. Possible values. <code>errors.schema_version</code> The version of the specification against which the API Firewall performed the request validation. <code>errors.related_fields</code> An array of parameters that violated the specification. <code>errors.related_fields_details</code> Details on parameters that violated the specification. <code>errors.related_fields_details.name</code> Parameter name. <code>errors.related_fields_details.expected_type</code> Expected parameter type (if the type is wrong). <code>errors.related_fields_details.current_value</code> Parameter value passed in a request. <code>errors.related_fields_details.pattern</code> Parameter value pattern specified in the specification."},{"location":"installation-guides/api-mode/#prometheus-metrics","title":"Prometheus metrics","text":"<p>To enable Prometheus-compatible metrics:</p> <ol> <li> <p>Set the <code>APIFW_METRICS_ENABLED</code> environment variable to <code>true</code>.</p> </li> <li> <p>If needed, customize the default Prometheus endpoint <code>http://&lt;host&gt;:9010/metrics</code> using the following environment variables:</p> <ul> <li><code>APIFW_METRICS_ENDPOINT_NAME</code>: the path at which the metrics endpoint is exposed.</li> <li><code>APIFW_METRICS_HOST</code>: the IP address and/or port for the metrics endpoint. When specifying a port, prefix it with a colon (<code>:</code>).</li> </ul> </li> <li> <p>Expose the metrics port in your container or deployment configuration (e.g., for the default state, use <code>-p 9010:9010</code>).</p> </li> </ol> <p>Once enabled, metrics are available at <code>http://&lt;host&gt;:9010/metrics</code> unless custom host or path are used.</p> <p>The following Prometheus metrics are exposed:</p> <pre><code># HELP wallarm_apifw_http_request_duration_seconds HTTP request duration in seconds\n# TYPE wallarm_apifw_http_request_duration_seconds histogram\nwallarm_apifw_http_request_duration_seconds_bucket{schema_id=\"1\",le=\"0.001\"} 2\nwallarm_apifw_http_request_duration_seconds_bucket{schema_id=\"1\",le=\"0.005\"} 2\nwallarm_apifw_http_request_duration_seconds_bucket{schema_id=\"1\",le=\"0.025\"} 2\nwallarm_apifw_http_request_duration_seconds_bucket{schema_id=\"1\",le=\"0.05\"} 2\nwallarm_apifw_http_request_duration_seconds_bucket{schema_id=\"1\",le=\"0.25\"} 2\nwallarm_apifw_http_request_duration_seconds_bucket{schema_id=\"1\",le=\"0.5\"} 2\nwallarm_apifw_http_request_duration_seconds_bucket{schema_id=\"1\",le=\"1\"} 2\nwallarm_apifw_http_request_duration_seconds_bucket{schema_id=\"1\",le=\"2.5\"} 2\nwallarm_apifw_http_request_duration_seconds_bucket{schema_id=\"1\",le=\"5\"} 2\nwallarm_apifw_http_request_duration_seconds_bucket{schema_id=\"1\",le=\"+Inf\"} 2\nwallarm_apifw_http_request_duration_seconds_sum{schema_id=\"1\"} 0.00028954100000000004\nwallarm_apifw_http_request_duration_seconds_count{schema_id=\"1\"} 2\n# HELP wallarm_apifw_http_requests_total Total number of HTTP requests\n# TYPE wallarm_apifw_http_requests_total counter\nwallarm_apifw_http_requests_total{schema_id=\"1\",status_code=\"200\"} 2\n# HELP wallarm_apifw_service_errors_total Total number of errors occurred in the APIFW service.\n# TYPE wallarm_apifw_service_errors_total counter\nwallarm_apifw_service_errors_total 0\n</code></pre>"},{"location":"installation-guides/api-mode/#database-issues","title":"Database issues","text":""},{"location":"installation-guides/api-mode/#handling-invalidity-in-an-already-mounted-sqlite-database","title":"Handling invalidity in an already mounted SQLite database","text":"<p>The API Firewall automatically retrieves specification updates from the mounted database at intervals defined by the <code>APIFW_SPECIFICATION_UPDATE_PERIOD</code> variable. If the database structure or specifications become invalid, or if the database file disappears post-update, the Firewall maintains the last valid specification file and pauses further updates. This method guarantees continuous operation with the most recent valid specifications until a correct database file is reestablished in the API Firewall.</p> <p>In cases where the database file is valid but contains an invalid specification, the API Firewall will disregard the faulty specification and proceed to load all valid specifications.</p> <p>Example</p> <p>Suppose the API Firewall has loaded two specifications, labeled 1 and 2. If specification 1 is modified and becomes invalid (due to syntax errors or parsing issues), the API Firewall will then only load and use specification 2. It will log an error message indicating the issue and will operate with only specification 2.</p>"},{"location":"installation-guides/api-mode/#mounting-empty-sqlite-database","title":"Mounting empty SQLite database","text":"<p>If the API Firewall is initiated with an empty, invalid, or non-existent database file, it will start and log errors if updates fail. In this state, the API Firewall will not have any specification, thus unable to validate requests, and will respond with a 500 status code. Note that the readiness probe will fail until a valid database is loaded.</p>"},{"location":"installation-guides/docker-container/","title":"Running API Firewall on Docker for REST API","text":"<p>This guide walks through downloading, installing, and starting Wallarm API Firewall on Docker for REST API request validation.</p>"},{"location":"installation-guides/docker-container/#requirements","title":"Requirements","text":"<ul> <li> <p>Installed and configured Docker</p> </li> <li> <p>OpenAPI 3.0 specification developed for the REST API of the application that should be protected with Wallarm API Firewall</p> </li> </ul>"},{"location":"installation-guides/docker-container/#methods-to-run-api-firewall-on-docker","title":"Methods to run API Firewall on Docker","text":"<p>The fastest method to deploy API Firewall on Docker is Docker Compose. The steps below rely on using this method.</p> <p>If required, you can also use <code>docker run</code>. We have provided proper <code>docker run</code> commands to deploy the same environment in this section.</p>"},{"location":"installation-guides/docker-container/#step-1-create-the-docker-composeyml-file","title":"Step 1. Create the <code>docker-compose.yml</code> file","text":"<p>To deploy API Firewall and proper environment using Docker Compose, create the docker-compose.yml with the following content first:</p> <pre><code>version: '3.8'\n\nnetworks:\n  api-firewall-network:\n    name: api-firewall-network\n\nservices:\n  api-firewall:\n    container_name: api-firewall\n    image: wallarm/api-firewall:v0.9.3\n    restart: on-failure\n    volumes:\n      - &lt;HOST_PATH_TO_SPEC&gt;:&lt;CONTAINER_PATH_TO_SPEC&gt;\n    environment:\n      APIFW_API_SPECS: &lt;PATH_TO_MOUNTED_SPEC&gt;\n      APIFW_URL: http://0.0.0.0:8088/\n      APIFW_SERVER_URL: &lt;PROTECTED_APP_URL&gt;\n      APIFW_REQUEST_VALIDATION: &lt;REQUEST_VALIDATION_MODE&gt;\n      APIFW_RESPONSE_VALIDATION: &lt;RESPONSE_VALIDATION_MODE&gt;\n    ports:\n      - \"8088:8088\"\n    stop_grace_period: 1s\n    networks:\n      - api-firewall-network\n  backend:\n    container_name: api-firewall-backend\n    image: kennethreitz/httpbin\n    restart: on-failure\n    ports:\n      - 80:80\n    stop_grace_period: 1s\n    networks:\n      - api-firewall-network\n</code></pre>"},{"location":"installation-guides/docker-container/#step-2-configure-the-docker-network","title":"Step 2. Configure the Docker network","text":"<p>If required, change the Docker network configuration defined in docker-compose.yml \u2192 <code>networks</code>.</p> <p>The provided docker-compose.yml instructs Docker to create the network <code>api-firewall-network</code> and link the application and API Firewall containers to it.</p> <p>It is recommended to use a separate Docker network to allow the containerized application and API Firewall communication without manual linking.</p>"},{"location":"installation-guides/docker-container/#step-3-configure-the-application-to-be-protected-with-api-firewall","title":"Step 3. Configure the application to be protected with API Firewall","text":"<p>Change the configuration of the containerized application to be protected with API Firewall. This configuration is defined in docker-compose.yml \u2192 <code>services.backend</code>.</p> <p>The provided docker-compose.yml instructs Docker to start the kennethreitz/httpbin Docker container connected to the <code>api-firewall-network</code> and assigned with the <code>backend</code> network alias. The container port is 80.</p> <p>If configuring your own application, define only settings required for the correct application container start. No specific configuration for API Firewall is required.</p>"},{"location":"installation-guides/docker-container/#step-4-configure-api-firewall","title":"Step 4. Configure API Firewall","text":"<p>Configure API Firewall as follows:</p> <ol> <li> <p>With <code>services.api-firewall.volumes</code>, mount the OpenAPI 3.0 specification to the API Firewall container directory:</p> <ul> <li><code>&lt;HOST_PATH_TO_SPEC&gt;</code>: the path to the OpenAPI 3.0 specification for your application REST API located on the host machine. The accepted file formats are YAML and JSON (<code>.yaml</code>, <code>.yml</code>, <code>.json</code> file extensions). For example: <code>/opt/my-api/openapi3/swagger.json</code>.</li> <li><code>&lt;CONTAINER_PATH_TO_SPEC&gt;</code>: the path to the container directory to mount the OpenAPI 3.0 specification to. For example: <code>/api-firewall/resources/swagger.json</code>.</li> </ul> </li> <li> <p>Set the general API Firewall configuration using one of the approaches:</p> <ul> <li>With <code>services.api-firewall.environment</code>, pass environment variables to docker-compose.yml \u2192 <code>services.api-firewall</code>.</li> <li>With <code>services.api-firewall.volumes</code>, mount the <code>apifw.yaml</code> configuation file to the API Firewall container directory.</li> </ul> <p>Priority</p> <p>If both specified, values in <code>apifw.yaml</code> have priority over environment variables.</p> </li> </ol> Environment variable YAML parameter Description Required? <code>APIFW_API_SPECS</code> <code>APISpecs</code> Path to the OpenAPI 3.0 specification. There are the following ways to specify the path:<ul><li>Path to the specification file mounted to the container, for example: <code>/api-firewall/resources/swagger.json</code>. When running the container, mount this file with the <code>-v &lt;HOST_PATH_TO_SPEC&gt;:&lt;CONTAINER_PATH_TO_SPEC&gt;</code> option.</li><li>URL address of the specification file, for example: <code>https://example.com/swagger.json</code>. When running the container, omit the <code>-v &lt;HOST_PATH_TO_SPEC&gt;:&lt;CONTAINER_PATH_TO_SPEC&gt;</code> option.</li></ul> Yes <code>APIFW_URL</code> Server \u2192 <code>APIHost</code> URL for API Firewall. For example: <code>http://0.0.0.0:8088/</code>. The port value should correspond to the container port published to the host.If API Firewall listens to the HTTPS protocol, please mount the generated SSL/TLS certificate and private key to the container, and pass to the container the API Firewall SSL/TLS settings.The default value is <code>http://0.0.0.0:8282/</code>. Yes <code>APIFW_SERVER_URL</code> Backend \u2192 ProtectedAPI \u2192 URL URL of the application described in the mounted OpenAPI specification that should be protected with API Firewall. For example: <code>http://backend:80</code>. Yes <code>APIFW_REQUEST_VALIDATION</code> <code>RequestValidation</code> API Firewall mode when validating requests sent to the application URL:<ul><li><code>BLOCK</code> to block and log the requests that do not match the schema provided in the mounted OpenAPI 3.0 specification (the <code>403 Forbidden</code> response will be returned to the blocked requests). Logs are sent to the <code>STDOUT</code> and <code>STDERR</code> Docker services.</li><li><code>LOG_ONLY</code> to log but not block the requests that do not match the schema provided in the mounted OpenAPI 3.0 specification. Logs are sent to the <code>STDOUT</code> and <code>STDERR</code> Docker services.</li><li><code>DISABLE</code> to disable request validation.Note that you can set validation mode for specific endpoints.</li></ul> Yes <code>APIFW_RESPONSE_VALIDATION</code> <code>ResponseValidation</code> API Firewall mode when validating application responses to incoming requests:<ul><li><code>BLOCK</code> to block and log the request if the application response to this request does not match the schema provided in the mounted OpenAPI 3.0 specification. This request will be proxied to the application URL but the client will receive the <code>403 Forbidden</code> response. Logs are sent to the <code>STDOUT</code> and <code>STDERR</code> Docker services.</li><li><code>LOG_ONLY</code> to log but not block the request if the application response to this request does not match the schema provided in the mounted OpenAPI 3.0 specification. Logs are sent to the <code>STDOUT</code> and <code>STDERR</code> Docker services.</li><li><code>DISABLE</code> to disable request validation.Note that you can set validation mode for specific endpoints.</li></ul> Yes <code>APIFW_LOG_LEVEL</code> - API Firewall logging level. Possible values:<ul><li><code>DEBUG</code> to log events of any type (INFO, ERROR, WARNING, and DEBUG).</li><li><code>INFO</code> to log events of the INFO, WARNING, and ERROR types.</li><li><code>WARNING</code> to log events of the WARNING and ERROR types.</li><li><code>ERROR</code> to log events of only the ERROR type.</li><li><code>TRACE</code> to log incoming requests and API Firewall responses, including their content.</li></ul> The default value is <code>DEBUG</code>. Logs on requests and responses that do not match the provided schema have the ERROR type. No <code>APIFW_CUSTOM_BLOCK_STATUS_CODE</code> <code>CustomBlockStatusCode</code> HTTP response status code returned by API Firewall operating in the <code>BLOCK</code> mode if the request or response does not match the schema provided in the mounted OpenAPI 3.0 specification. The default value is <code>403</code>. No <code>APIFW_ADD_VALIDATION_STATUS_HEADER</code>(EXPERIMENTAL) <code>AddValidationStatusHeader</code> Whether to return the header <code>Apifw-Validation-Status</code> containing the reason for the request blocking in the response to this request. The value can be <code>true</code> or <code>false</code>. The default value is <code>false</code>. No <code>APIFW_SERVER_DELETE_ACCEPT_ENCODING</code> <code>DeleteAcceptEncoding</code> If it is set to <code>true</code>, the <code>Accept-Encoding</code> header is deleted from proxied requests. The default value is <code>false</code>. No <code>APIFW_LOG_FORMAT</code> - The format of API Firewall logs. The value can be <code>TEXT</code> or <code>JSON</code>. The default value is <code>TEXT</code>. No <code>APIFW_SHADOW_API_EXCLUDE_LIST</code>(only if API Firewall is operating in the <code>LOG_ONLY</code> mode for both the requests and responses) ShadowAPI \u2192 <code>ExcludeList</code> HTTP response status codes indicating that the requested API endpoint that is not included in the specification is NOT a shadow one. You can specify several status codes separated by a semicolon (e.g. <code>404;401</code>). The default value is <code>404</code>.By default, API Firewall operating in the <code>LOG_ONLY</code> mode for both the requests and responses marks all endpoints that are not included in the specification and are returning the code different from <code>404</code> as the shadow ones. No <code>APIFW_MODE</code> <code>mode</code> Sets the general API Firewall mode. Possible values are <code>PROXY</code> (default), <code>graphql</code> and <code>API</code>. No <code>APIFW_PASS_OPTIONS</code> <code>PassOptionsRequests</code> When set to <code>true</code>, the API Firewall allows <code>OPTIONS</code> requests to endpoints in the specification, even if the <code>OPTIONS</code> method is not described. The default value is <code>false</code>. No <code>APIFW_SHADOW_API_UNKNOWN_PARAMETERS_DETECTION</code> ShadowAPI \u2192 <code>UnknownParametersDetection</code> This specifies whether requests are identified as non-matching the specification if their parameters do not align with those defined in the OpenAPI specification. The default value is <code>true</code>.If running API Firewall in the <code>API</code> mode, this variable takes on a different name <code>APIFW_API_MODE_UNKNOWN_PARAMETERS_DETECTION</code>. No <code>APIFW_API_SPECS_CUSTOM_HEADER_NAME</code> APISpecsCustomHeader \u2192 <code>Name</code> Specifies the custom header name to be added to requests for your OpenAPI specification URL (defined in <code>APIFW_API_SPECS</code>). For example, you can specify a header name for authentication data required to access the URL. No <code>APIFW_API_SPECS_CUSTOM_HEADER_VALUE</code> APISpecsCustomHeader \u2192 <code>Value</code> Specifies the custom header value to be added to requests for your OpenAPI specification URL. For example, you can specify authentication data for the custom header defined in <code>APIFW_API_SPECS_CUSTOM_HEADER_NAME</code> to access the URL. No <code>APIFW_SPECIFICATION_UPDATE_PERIOD</code> <code>SpecificationUpdatePeriod</code> Specifies the interval for updating the OpenAPI specification from the hosted URL (defined in <code>APIFW_API_SPECS</code>). The default value is <code>0</code>, which disables updates and uses the initially downloaded specification. The value format is: <code>5s</code>, <code>1h</code>, etc. No <code>APIFW_MODSEC_CONF_FILES</code> ModSecurity \u2192 <code>ConfFiles</code> Allows to set the list of ModSecurity configuration files. The delimiter is ;. The default value is [] (empty). Example: <code>APIFW_MODSEC_CONF_FILES=modsec.conf;crs-setup.conf.example</code>. No <code>APIFW_MODSEC_RULES_DIR</code> ModSecurity \u2192 <code>RulesDir</code> Allows to set the ModSecurity directory with the rules that should be loaded. The files with the <code>*.conf</code> wildcard will be loaded from the directory. The default value is <code>\"\"</code>. No <code>APIFW_SERVER_REQUEST_HOST_HEADER</code> <code>RequestHostHeader</code> Sets a custom <code>Host</code> header for requests forwarded to your backend after API Firewall validation. No <code>APIFW_MODSEC_REQUEST_VALIDATION</code> ModSecurity \u2192 <code>RequestValidation</code> Defines how requests to the application URL are validated against the ModSecurity Rule Set.<ul><li><code>BLOCK</code> to block and log the requests that violate the ModSecurity Rule Set (the <code>403 Forbidden</code> response will be returned to the blocked requests). Logs are sent to the <code>STDOUT</code> and <code>STDERR</code> Docker services.</li><li><code>LOG_ONLY</code> to log but not block the requests that violate the rule set. Logs are sent to the <code>STDOUT</code> and <code>STDERR</code> Docker services.</li><li><code>DISABLE</code> (default) to disable request validation against the ModSecurity Rule Set.</li></ul>This setting takes priority if used together with <code>APIFW_REQUEST_VALIDATION</code>. No <code>APIFW_MODSEC_RESPONSE_VALIDATION</code> ModSecurity \u2192 <code>ResponseValidation</code> Defines how application responses are validated against the ModSecurity Rule Set.<ul><li><code>BLOCK</code> to block and log the corresponding requests (the <code>403 Forbidden</code> response will be returned to the blocked requests). Logs are sent to the <code>STDOUT</code> and <code>STDERR</code> Docker services.</li><li><code>LOG_ONLY</code> to log but not block the corresponding requests. Logs are sent to the <code>STDOUT</code> and <code>STDERR</code> Docker services.</li><li><code>DISABLE</code> (default) to disable response validation against the ModSecurity Rule Set.</li></ul>This setting takes priority if used together with <code>APIFW_RESPONSE_VALIDATION</code>. No <p></p> Example of <code>apifw.yaml</code> <pre><code>mode: \"PROXY\"\nRequestValidation: \"BLOCK\"\nResponseValidation: \"BLOCK\"\nModSecurity:\n  RequestValidation: \"LOG_ONLY\"\n  ResponseValidation: \"LOG_ONLY\"\nCustomBlockStatusCode: 403\nAddValidationStatusHeader: false\nAPISpecs: \"openapi.yaml\"\nAPISpecsCustomHeader:\n  Name: \"\"\n  Value: \"\"\nPassOptionsRequests: true\nSpecificationUpdatePeriod: \"0\"\nServer:\n  APIHost: \"http://0.0.0.0:8282\"\n  HealthAPIHost: \"0.0.0.0:9999\"\n  ReadTimeout: \"5s\"\n  WriteTimeout: \"5s\"\n  ReadBufferSize: 8192\n  WriteBufferSize: 8192\n  MaxRequestBodySize: 4194304\n  DisableKeepalive: false\n  MaxConnsPerIP: 0\n  MaxRequestsPerConn: 0\nDNS:\n  Nameserver:\n    Host: \"\"\n    Port: \"53\"\n    Proto: \"udp\"\n  Cache: false\n  FetchTimeout: \"1m\"\n  LookupTimeout: \"1s\"\nDenylist:\n  Tokens:\n    CookieName: \"\"\n    HeaderName: \"\"\n    TrimBearerPrefix: true\n    File: \"\"\nAllowIP:\n  File: \"\"\n  HeaderName: \"\"\nShadowAPI:\n  ExcludeList:\n    - 404\n    - 200\n  UnknownParametersDetection: false\nTLS:\n  CertsPath: \"certs\"\n  CertFile: \"localhost.crt\"\n  CertKey: \"localhost.key\"\nModSecurity:\n  ConfFiles: []\n  RulesDir: \"\"\nEndpoints: []\nBackend:\n  Oauth:\n    ValidationType: \"JWT\"\n    JWT:\n      SignatureAlgorithm: \"RS256\"\n      PubCertFile: \"\"\n      SecretKey: \"\"\n    Introspection:\n      ClientAuthBearerToken: \"\"\n      Endpoint: \"\"\n      EndpointParams: \"\"\n      TokenParamName: \"\"\n      ContentType: \"\"\n      EndpointMethod: \"GET\"\n      RefreshInterval: \"10m\"\n  ProtectedAPI:\n    URL: \"http://localhost:3000/v1/\"\n    RequestHostHeader: \"\"\n    ClientPoolCapacity: 1000\n    InsecureConnection: false\n    RootCA: \"\"\n    MaxConnsPerHost: 512\n    ReadTimeout: \"5s\"\n    WriteTimeout: \"5s\"\n    DialTimeout: \"200ms\"\n    ReadBufferSize: 8192\n    WriteBufferSize: 8192\n    MaxResponseBodySize: 0\n    DeleteAcceptEncoding: false\n</code></pre> <p>With <code>services.api-firewall.ports</code> and <code>services.api-firewall.networks</code>, set the API Firewall container port and connect the container to the created network. The provided docker-compose.yml instructs Docker to start API Firewall connected to the <code>api-firewall-network</code> network on the port 8088.</p>"},{"location":"installation-guides/docker-container/#step-5-deploy-the-configured-environment","title":"Step 5. Deploy the configured environment","text":"<p>To build and start the configured environment, run the following command:</p> <pre><code>docker-compose up -d --force-recreate\n</code></pre> <p>To check the log output:</p> <pre><code>docker-compose logs -f\n</code></pre>"},{"location":"installation-guides/docker-container/#step-6-test-api-firewall-operation","title":"Step 6. Test API Firewall operation","text":"<p>To test API Firewall operation, send the request that does not match the mounted Open API 3.0 specification to the API Firewall Docker container address. For example, you can pass the string value in the parameter that requires the integer value.</p> <p>If the request does not match the provided API schema, the appropriate ERROR message will be added to the API Firewall Docker container logs.</p>"},{"location":"installation-guides/docker-container/#step-7-enable-traffic-on-api-firewall","title":"Step 7. Enable traffic on API Firewall","text":"<p>To finalize the API Firewall configuration, please enable incoming traffic on API Firewall by updating your application deployment scheme configuration. For example, this would require updating the Ingress, NGINX, or load balancer settings.</p>"},{"location":"installation-guides/docker-container/#stopping-the-deployed-environment","title":"Stopping the deployed environment","text":"<p>To stop the environment deployed using Docker Compose, run the following command:</p> <pre><code>docker-compose down\n</code></pre>"},{"location":"installation-guides/docker-container/#using-docker-run-to-start-api-firewall","title":"Using <code>docker run</code> to start API Firewall","text":"<p>To start API Firewall on Docker, you can also use regular Docker commands as in the examples below:</p> <ol> <li> <p>To create a separate Docker network to allow the containerized application and API Firewall communication without manual linking:</p> <pre><code>docker network create api-firewall-network\n</code></pre> </li> <li> <p>To start the containerized application to be protected with API Firewall:</p> <pre><code>docker run --rm -it --network api-firewall-network \\\n    --network-alias backend -p 80:80 kennethreitz/httpbin\n</code></pre> </li> <li> <p>To start API Firewall:</p> <pre><code>docker run --rm -it --network api-firewall-network --network-alias api-firewall \\\n    -v &lt;HOST_PATH_TO_SPEC&gt;:&lt;CONTAINER_PATH_TO_SPEC&gt; -e APIFW_API_SPECS=&lt;PATH_TO_MOUNTED_SPEC&gt; \\\n    -e APIFW_URL=&lt;API_FIREWALL_URL&gt; -e APIFW_SERVER_URL=&lt;PROTECTED_APP_URL&gt; \\\n    -e APIFW_REQUEST_VALIDATION=&lt;REQUEST_VALIDATION_MODE&gt; -e APIFW_RESPONSE_VALIDATION=&lt;RESPONSE_VALIDATION_MODE&gt; \\\n    -p 8088:8088 wallarm/api-firewall:v0.9.3\n</code></pre> </li> <li> <p>When the environment is started, test it and enable traffic on API Firewall following steps 6 and 7.</p> </li> </ol>"},{"location":"installation-guides/graphql/docker-container/","title":"Running API Firewall on Docker for GraphQL API","text":"<p>This guide walks through downloading, installing, and starting Wallarm API Firewall on Docker for GraphQL API request validation. In GraphQL mode, the API Firewall acts as a proxy, forwarding GraphQL requests from users to the backend server using either HTTP or the WebSocket (<code>graphql-ws</code>) protocols. Before the backend execution, the firewall checks the query complexity, depth, and node count of the GraphQL query.</p> <p>The API Firewall does not validate GraphQL query responses.</p>"},{"location":"installation-guides/graphql/docker-container/#requirements","title":"Requirements","text":"<ul> <li> <p>Installed and configured Docker</p> </li> <li> <p>GraphQL specification developed for the GraphQL API of the application that should be protected with Wallarm API Firewall</p> </li> </ul>"},{"location":"installation-guides/graphql/docker-container/#methods-to-run-api-firewall-on-docker","title":"Methods to run API Firewall on Docker","text":"<p>The fastest method to deploy API Firewall on Docker is Docker Compose. The steps below rely on using this method.</p> <p>If required, you can also use <code>docker run</code>. We have provided proper <code>docker run</code> commands to deploy the same environment in this section.</p>"},{"location":"installation-guides/graphql/docker-container/#step-1-create-the-docker-composeyml-file","title":"Step 1. Create the <code>docker-compose.yml</code> file","text":"<p>To deploy API Firewall and proper environment using Docker Compose, create the docker-compose.yml with the following content first. In the further steps, you will change this template.</p> <pre><code>version: '3.8'\n\nnetworks:\n  api-firewall-network:\n    name: api-firewall-network\n\nservices:\n  api-firewall:\n    container_name: api-firewall\n    image: wallarm/api-firewall:v0.9.3\n    restart: on-failure\n    volumes:\n      - &lt;HOST_PATH_TO_SPEC&gt;:&lt;CONTAINER_PATH_TO_SPEC&gt;\n    environment:\n      APIFW_MODE: graphql\n      APIFW_GRAPHQL_SCHEMA: &lt;PATH_TO_MOUNTED_SPEC&gt;\n      APIFW_URL: &lt;API_FIREWALL_URL&gt;\n      APIFW_SERVER_URL: &lt;PROTECTED_APP_URL&gt;\n      APIFW_GRAPHQL_REQUEST_VALIDATION: &lt;REQUEST_VALIDATION_MODE&gt;\n      APIFW_GRAPHQL_MAX_QUERY_COMPLEXITY: &lt;MAX_QUERY_COMPLEXITY&gt;\n      APIFW_GRAPHQL_MAX_QUERY_DEPTH: &lt;MAX_QUERY_DEPTH&gt;\n      APIFW_GRAPHQL_NODE_COUNT_LIMIT: &lt;NODE_COUNT_LIMIT&gt;\n      APIFW_GRAPHQL_INTROSPECTION: &lt;ALLOW_INTROSPECTION_OR_NOT&gt;\n    ports:\n      - \"8088:8088\"\n    stop_grace_period: 1s\n    networks:\n      - api-firewall-network\n  backend:\n    container_name: api-firewall-backend\n    image: &lt;IMAGE_WITH_GRAPHQL_APP&gt;\n    restart: on-failure\n    ports:\n      - &lt;HOST_PORT&gt;:&lt;CONTAINER_PORT&gt;\n    stop_grace_period: 1s\n    networks:\n      - api-firewall-network\n</code></pre>"},{"location":"installation-guides/graphql/docker-container/#step-2-configure-the-docker-network","title":"Step 2. Configure the Docker network","text":"<p>If required, change the Docker network configuration defined in docker-compose.yml \u2192 <code>networks</code>.</p> <p>The provided docker-compose.yml instructs Docker to create the network <code>api-firewall-network</code> and link the application and API Firewall containers to it.</p> <p>It is recommended to use a separate Docker network for protected contanerized application and API Firewall to allow their communication without manual linking.</p>"},{"location":"installation-guides/graphql/docker-container/#step-3-configure-the-application-to-be-protected-with-api-firewall","title":"Step 3. Configure the application to be protected with API Firewall","text":"<p>Change the configuration of the containerized application to be protected with API Firewall. This configuration is defined in docker-compose.yml \u2192 <code>services.backend</code>.</p> <p>The template instructs Docker to boot the specified application Docker container, connecting it to the <code>api-firewall-network</code> and designating the <code>backend</code> network alias. You can define the port as per your requirements.</p> <p>When setting up your application, include only the necessary settings for a successful container launch. No special API Firewall configuration is required.</p>"},{"location":"installation-guides/graphql/docker-container/#step-4-configure-api-firewall","title":"Step 4. Configure API Firewall","text":"<p>Pass API Firewall configuration in docker-compose.yml \u2192 <code>services.api-firewall</code> as follows:</p> <p>With <code>services.api-firewall.volumes</code>, mount the GraphQL specification to the API Firewall container directory:</p> <ul> <li> <p><code>&lt;HOST_PATH_TO_SPEC&gt;</code>: the path to the GraphQL specification for your API located on the host machine. The file format does not matter but usually it is <code>.graphql</code> or <code>gql</code>. For example: <code>/opt/my-api/graphql/schema.graphql</code>.</p> </li> <li> <p><code>&lt;CONTAINER_PATH_TO_SPEC&gt;</code>: the path to the container directory to mount the GraphQL specification to. For example: <code>/api-firewall/resources/schema.graphql</code>.</p> </li> </ul> <p>With <code>services.api-firewall.environment</code>, please set the general API Firewall configuration through the following environment variables:</p> Environment variable Description Required? <code>APIFW_MODE</code> Sets the general API Firewall mode. Possible values are <code>PROXY</code> (default), <code>graphql</code> and <code>API</code>. No <code>APIFW_GRAPHQL_SCHEMA</code> Path to the GraphQL specification file mounted to the container, for example: <code>/api-firewall/resources/schema.graphql</code>. Yes <code>APIFW_URL</code> URL for API Firewall. For example: <code>http://0.0.0.0:8088/</code>. The port value should correspond to the container port published to the host.If API Firewall listens to the HTTPS protocol, please mount the generated SSL/TLS certificate and private key to the container, and pass to the container the API Firewall SSL/TLS settings described below. Yes <code>APIFW_SERVER_URL</code> URL of the application described in the mounted specification that should be protected with API Firewall. For example: <code>http://backend:80</code>. Yes <code>APIFW_GRAPHQL_REQUEST_VALIDATION</code> API Firewall mode when validating requests sent to the application URL:<ul><li><code>BLOCK</code> blocks and logs requests not matching the mounted GraphQL schema, returning a <code>403 Forbidden</code>. Logs are sent to the <code>STDOUT</code> and <code>STDERR</code> Docker services.</li><li><code>LOG_ONLY</code> logs (but does not block) mismatched requests.</li><li><code>DISABLE</code> turns off request validation.</li></ul>This variable impacts all other parameters, except <code>APIFW_GRAPHQL_WS_CHECK_ORIGIN</code>. For instance, if <code>APIFW_GRAPHQL_INTROSPECTION</code> is <code>false</code> and the mode is <code>LOG_ONLY</code>, introspection requests reach the backend server, but API Firewall generates a corresponding error log. Yes <code>APIFW_GRAPHQL_MAX_QUERY_COMPLEXITY</code> Defines the maximum number of Node requests that might be needed to execute the query. Setting it to <code>0</code> disables the complexity check. The default value is <code>0</code>. Yes <code>APIFW_GRAPHQL_MAX_QUERY_DEPTH</code> Specifies the maximum permitted depth of a GraphQL query. A value of <code>0</code> means the query depth check is skipped. Yes <code>APIFW_GRAPHQL_NODE_COUNT_LIMIT</code> Sets the upper limit for the node count in a query. When set to <code>0</code>, the node count limit check is skipped. Yes <code>APIFW_GRAPHQL_MAX_ALIASES_NUM</code> Sets a limit on the number of aliases that can be used in a GraphQL document. If this variable is set to <code>0</code>, it implies that there is no limit on the number of aliases that can be used. Yes <code>APIFW_GRAPHQL_INTROSPECTION</code> Allows introspection queries, which disclose the layout of your GraphQL schema. When set to <code>true</code>, these queries are permitted. Yes <code>APIFW_GRAPHQL_FIELD_DUPLICATION</code> Defines whether to allow or prevent the duplication of fields in a GraphQL document. The default value is <code>false</code> (prevent). No <code>APIFW_GRAPHQL_BATCH_QUERY_LIMIT</code> Sets a limit on the number of queries that can be batched together in a single GraphQL request. If this variable is set to <code>0</code>, it implies that there is no limit on the number of batched queries. No <code>APIFW_LOG_LEVEL</code> API Firewall logging level. Possible values:<ul><li><code>DEBUG</code> to log events of any type (INFO, ERROR, WARNING, and DEBUG).</li><li><code>INFO</code> to log events of the INFO, WARNING, and ERROR types.</li><li><code>WARNING</code> to log events of the WARNING and ERROR types.</li><li><code>ERROR</code> to log events of only the ERROR type.</li><li><code>TRACE</code> to log incoming requests and API Firewall responses, including their content.</li></ul> The default value is <code>DEBUG</code>. Logs on requests and responses that do not match the provided schema have the ERROR type. No <code>APIFW_SERVER_DELETE_ACCEPT_ENCODING</code> If it is set to <code>true</code>, the <code>Accept-Encoding</code> header is deleted from proxied requests. The default value is <code>false</code>. No <code>APIFW_LOG_FORMAT</code> The format of API Firewall logs. The value can be <code>TEXT</code> or <code>JSON</code>. The default value is <code>TEXT</code>. No <code>APIFW_SERVER_REQUEST_HOST_HEADER</code> Sets a custom <code>Host</code> header for requests forwarded to your backend after API Firewall validation. No <p>With <code>services.api-firewall.ports</code> and <code>services.api-firewall.networks</code>, set the API Firewall container port and connect the container to the created network.</p>"},{"location":"installation-guides/graphql/docker-container/#step-5-deploy-the-configured-environment","title":"Step 5. Deploy the configured environment","text":"<p>To build and start the configured environment, run the following command:</p> <pre><code>docker-compose up -d --force-recreate\n</code></pre> <p>To check the log output:</p> <pre><code>docker-compose logs -f\n</code></pre>"},{"location":"installation-guides/graphql/docker-container/#step-6-test-api-firewall-operation","title":"Step 6. Test API Firewall operation","text":"<p>To test API Firewall operation, send the request that does not match the mounted GraphQL specification to the API Firewall Docker container address.</p> <p>With <code>APIFW_GRAPHQL_REQUEST_VALIDATION</code> set to <code>BLOCK</code>, the firewall works as follows:</p> <ul> <li> <p>If the API Firewall allows the request, it proxies the request to the backend server. </p> </li> <li> <p>If the API Firewall cannot parse the request, it responds with the GraphQL error with a 500 status code.</p> </li> <li> <p>If the validation fails by the API Firewall, it does not proxy the request to the backend server but responds to the client with 200 status code and GraphQL error in response. </p> </li> </ul> <p>If the request does not match the provided API schema:</p> <ul> <li> <p>The API Firewall returns the following response:</p> <pre><code>{\n  \"errors\": [\n    {\n      \"message\":\"invalid query\"\n    }\n  ]\n}\n</code></pre> </li> <li> <p>The appropriate ERROR message is added to the API Firewall Docker container logs, e.g. in the JSON format:</p> <pre><code>{\n  \"errors\": [\n    {\n      \"message\": \"field: name not defined on type: Query\",\n      \"path\": [\n        \"query\",\n        \"name\"\n      ]\n    }\n  ]\n}\n</code></pre> </li> </ul> <p>In scenarios where multiple fields in the request are invalid, only a singular error message will be generated.</p>"},{"location":"installation-guides/graphql/docker-container/#step-7-enable-traffic-on-api-firewall","title":"Step 7. Enable traffic on API Firewall","text":"<p>To finalize the API Firewall configuration, please enable incoming traffic on API Firewall by updating your application deployment scheme configuration. For example, this would require updating the Ingress, NGINX, or load balancer settings.</p>"},{"location":"installation-guides/graphql/docker-container/#stopping-the-deployed-environment","title":"Stopping the deployed environment","text":"<p>To stop the environment deployed using Docker Compose, run the following command:</p> <pre><code>docker-compose down\n</code></pre>"},{"location":"installation-guides/graphql/docker-container/#using-docker-run-to-start-api-firewall","title":"Using <code>docker run</code> to start API Firewall","text":"<p>To start API Firewall on Docker, you can also use regular Docker commands as in the examples below:</p> <ol> <li> <p>To create a separate Docker network to allow the containerized application and API Firewall communication without manual linking:</p> <pre><code>docker network create api-firewall-network\n</code></pre> </li> <li> <p>Start the containerized application to be protected with API Firewall:</p> <pre><code>docker run --rm -it --network api-firewall-network \\\n    --network-alias backend -p &lt;HOST_PORT&gt;:&lt;CONTAINER_PORT&gt; &lt;IMAGE_WITH_GRAPHQL_APP&gt;\n</code></pre> </li> <li> <p>To start API Firewall:</p> <pre><code>docker run --rm -it --network api-firewall-network --network-alias api-firewall \\\n    -v &lt;HOST_PATH_TO_SPEC&gt;:&lt;CONTAINER_PATH_TO_SPEC&gt; -e APIFW_MODE=graphql \\\n    -e APIFW_GRAPHQL_SCHEMA=&lt;PATH_TO_MOUNTED_SPEC&gt; -e APIFW_URL=&lt;API_FIREWALL_URL&gt; \\\n    -e APIFW_SERVER_URL=&lt;PROTECTED_APP_URL&gt; -e APIFW_GRAPHQL_REQUEST_VALIDATION=&lt;REQUEST_VALIDATION_MODE&gt; \\\n    -e APIFW_GRAPHQL_MAX_QUERY_COMPLEXITY=&lt;MAX_QUERY_COMPLEXITY&gt; \\\n    -e APIFW_GRAPHQL_MAX_QUERY_DEPTH=&lt;MAX_QUERY_DEPTH&gt; -e APIFW_GRAPHQL_NODE_COUNT_LIMIT=&lt;NODE_COUNT_LIMIT&gt; \\\n    -e APIFW_GRAPHQL_INTROSPECTION=&lt;ALLOW_INTROSPECTION_OR_NOT&gt; \\\n    -p 8088:8088 wallarm/api-firewall:v0.9.3\n</code></pre> </li> <li> <p>When the environment is started, test it and enable traffic on API Firewall following steps 6 and 7.</p> </li> </ol>"},{"location":"installation-guides/graphql/limit-compliance/","title":"GraphQL Limits Compliance","text":"<p>You can configure the API Firewall to validate incoming GraphQL queries against predefined query constraints. By adhering to these limits, you can shield your GraphQL API from malicious queries, including potential DoS attacks. This guide explains how the firewall calculates query attributes like node requests, query depth, and complexity before aligning them with your set parameters.</p> <p>When running the API Firewall Docker container for a GraphQL API, you set limits using the following environment variables:</p> Environment variable Description <code>APIFW_GRAPHQL_MAX_QUERY_COMPLEXITY</code> Defines the maximum number of Node requests that might be needed to execute the query. Setting it to <code>0</code> disables the complexity check. <code>APIFW_GRAPHQL_MAX_QUERY_DEPTH</code> Specifies the maximum permitted depth of a GraphQL query. A value of <code>0</code> means the query depth check is skipped. <code>APIFW_GRAPHQL_NODE_COUNT_LIMIT</code> Sets the upper limit for the node count in a query. When set to <code>0</code>, the node count limit check is skipped. <code>APIFW_GRAPHQL_MAX_ALIASES_NUM</code> Sets a limit on the number of aliases that can be used in a GraphQL document. If this variable is set to <code>0</code>, it implies that there is no limit on the number of aliases that can be used. <code>APIFW_GRAPHQL_FIELD_DUPLICATION</code> Defines whether to allow or prevent the duplication of fields in a GraphQL document. The default value is <code>false</code> (prevent). <code>APIFW_GRAPHQL_BATCH_QUERY_LIMIT</code> Sets a limit on the number of queries that can be batched together in a single GraphQL request. If this variable is set to <code>0</code>, it implies that there is no limit on the number of batched queries."},{"location":"installation-guides/graphql/limit-compliance/#how-limit-calculation-works","title":"How limit calculation works","text":"<p>API Firewall leverages the wundergraph/graphql-go-tools library, which adopts algorithms similar to those used by GitHub for calculating GraphQL query complexity. Central to this is the <code>OperationComplexityEstimator</code> function, which processes a schema definition and a query, iteratively examining the query to get both its complexity and depth.</p> <p>You can fine-tune this calculation by integrating integer arguments on fields that signify the number of Nodes a field returns:</p> <ul> <li> <p><code>directive @nodeCountMultiply on ARGUMENT_DEFINITION</code></p> <p>Indicates that the Int value the directive is applied on should be used as a Node multiplier.</p> </li> <li> <p><code>directive @nodeCountSkip on FIELD</code>     Indicates that the algorithm should skip this Node. This is useful to whitelist certain query paths, e.g. for introspection.</p> </li> </ul> <p>For documents with multiple queries, the calculated complexity, depth, and node count apply to the whole document, not just the single query being run.</p>"},{"location":"installation-guides/graphql/limit-compliance/#calculation-examples","title":"Calculation examples","text":"<p>Below there are a few examples which will grant a clearer perspective on the calculations. They are based on the following GraphQL schema:</p> <pre><code>type User {\n    name: String!\n    messages(first: Int! @nodeCountMultiply): [Message]\n}\n\ntype Message {\n    id: ID!\n    text: String!\n    createdBy: String!\n    createdAt: Time!\n}\n\ntype Query {\n        __schema: __Schema! @nodeCountSkip\n    users(first: Int! @nodeCountMultiply): [User]\n    messages(first: Int! @nodeCountMultiply): [Message]\n}\n\ntype Mutation {\n    post(text: String!, username: String!, roomName: String!): Message!\n}\n\ntype Subscription {\n    messageAdded(roomName: String!): Message!\n}\n\nscalar Time\n\ndirective @nodeCountMultiply on ARGUMENT_DEFINITION\ndirective @nodeCountSkip on FIELD\n</code></pre> <p>The depth always represents the nesting levels of fields. For instance, the query below has a depth of 3:</p> <pre><code>{\n    a {\n        b {\n            c\n        }\n    }\n}\n</code></pre>"},{"location":"installation-guides/graphql/limit-compliance/#example-1","title":"Example 1","text":"<pre><code>query {\n  users(first: 10) {\n    name\n    messages(first:100) {\n      id\n      text\n    }\n  }\n}\n</code></pre> <ul> <li> <p>NodeCount = {int} 1010</p> <pre><code>Node count = 10 [users(first: 10)] + 10*100 [messages(first:100)] = 1010\n</code></pre> </li> <li> <p>Complexity = {int} 11</p> <pre><code>Complexity = 1 [users(first: 10)] + 10 [messages(first:100)] = 11\n</code></pre> </li> <li> <p>Depth = {int} 3</p> </li> </ul>"},{"location":"installation-guides/graphql/limit-compliance/#example-2","title":"Example 2","text":"<pre><code>query {\n  users(first: 10) {\n    name\n  }\n}\n</code></pre> <ul> <li> <p>NodeCount = {int} 10</p> <pre><code>Node count = 10 [users(first: 10)] = 10\n</code></pre> </li> <li> <p>Complexity = {int} 1</p> <pre><code>Complexity = 1 [users(first: 10)] = 1\n</code></pre> </li> <li> <p>Depth = {int} 2</p> </li> </ul>"},{"location":"installation-guides/graphql/limit-compliance/#example-3","title":"Example 3","text":"<pre><code>query {\n  message(id:1) {\n    id\n    text\n  }\n}\n</code></pre> <ul> <li> <p>NodeCount = {int} 1</p> <pre><code>Node count = 1 [message(fid:1)] = 1\n</code></pre> </li> <li> <p>Complexity = {int} 1</p> <pre><code>Complexity = 1 [messages(first:1)] = 1\n</code></pre> </li> <li> <p>Depth = {int} 2</p> </li> </ul>"},{"location":"installation-guides/graphql/limit-compliance/#example-4","title":"Example 4","text":"<pre><code>query {\n  users(first: 10) {\n    name\n    messages(first:1) {\n      id\n      text\n    }\n  }\n}\n</code></pre> <ul> <li> <p>NodeCount = {int} 20</p> <pre><code>Node count = 10 [users(first: 10)] + 10*1 [messages(first:1)] = 20\n</code></pre> </li> <li> <p>Complexity = {int} 11</p> <pre><code>Complexity = 1 [users(first: 10)] + 10 [messages(first:1)] = 11\n</code></pre> </li> <li> <p>Depth = {int} 3</p> </li> </ul>"},{"location":"installation-guides/graphql/limit-compliance/#example-5-introspection-query","title":"Example 5 (introspection query)","text":"<pre><code>query IntrospectionQuery {\n  __schema {\n    queryType {\n      name\n    }\n    mutationType {\n      name\n    }\n    subscriptionType {\n      name\n    }\n    types {\n      ...FullType\n    }\n    directives {\n      name\n      description\n      locations\n      args {\n        ...InputValue\n      }\n    }\n  }\n}\n\nfragment FullType on __Type {\n  kind\n  name\n  description\n  fields(includeDeprecated: true) {\n    name\n    description\n    args {\n      ...InputValue\n    }\n    type {\n      ...TypeRef\n    }\n    isDeprecated\n    deprecationReason\n  }\n  inputFields {\n    ...InputValue\n  }\n  interfaces {\n    ...TypeRef\n  }\n  enumValues(includeDeprecated: true) {\n    name\n    description\n    isDeprecated\n    deprecationReason\n  }\n  possibleTypes {\n    ...TypeRef\n  }\n}\n\nfragment InputValue on __InputValue {\n  name\n  description\n  type {\n    ...TypeRef\n  }\n  defaultValue\n}\n\nfragment TypeRef on __Type {\n  kind\n  name\n  ofType {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <ul> <li> <p>NodeCount = {int} 0</p> </li> <li> <p>Complexity = {int} 0</p> </li> <li> <p>Depth = {int} 0</p> </li> </ul> <p>Since the <code>__schema: __Schema! @nodeCountSkip</code> directive is present in the schema, the calculated NodeCount, Complexity, and Depth are all 0.</p>"},{"location":"installation-guides/graphql/limit-compliance/#example-6-limiting-batched-queries","title":"Example 6 (limiting batched queries)","text":"<p>Assume you have set the <code>APIFW_GRAPHQL_BATCH_QUERY_LIMIT</code> environment variable to <code>2</code>. If you attempt to execute the following batch of 3 GraphQL queries sequentially against the backend:</p> <pre><code>[\n  {\"query\":\"query {\\n  systemHealth\\n}\",\"variables\":[]},\n  {\"query\":\"query {\\n  systemHealth\\n}\",\"variables\":[]},\n  {\"query\":\"query {\\n  systemHealth\\n}\",\"variables\":[]}\n]\n</code></pre> <p>The API Firewall will intercept this request and log an error, indicating that the number of queries in the batch exceeds the configured limit. The logged error message will be:</p> <pre><code>ERROR GraphQL query validation error=the batch query limit has been exceeded. The number of queries in the batch is 3. The current batch query limit is 2 protocol=HTTP\n</code></pre>"},{"location":"installation-guides/graphql/playground/","title":"GraphQL Playground in API Firewall","text":"<p>Wallarm API Firewall equips developers with the GraphQL Playground. This guide explains how to run the playground.</p> <p>GraphQL Playground is an in-browser Integrated Development Environment (IDE) specifically for GraphQL. It is designed as a visual platform where developers can effortlessly write, examine, and delve into the myriad possibilities of GraphQL queries, mutations, and subscriptions.</p> <p>The playground automatically fetches the schema from the URL set in <code>APIFW_SERVER_URL</code>. This action is an introspection query that discloses the GraphQL schema. Therefore, it is required to ensure the <code>APIFW_GRAPHQL_INTROSPECTION</code> variable is set to <code>true</code>. Doing so permits this process, averting potential errors in the API Firewall logs.</p> <p>To activate the Playground within the API Firewall, you need to use the following environment variables:</p> Environment variable Description <code>APIFW_GRAPHQL_INTROSPECTION</code> Allows introspection queries, which disclose the layout of your GraphQL schema. Ensure this variable is set to <code>true</code>. <code>APIFW_GRAPHQL_PLAYGROUND</code> Toggles the playground feature. By default, it is set to <code>false</code>. To enable, change to <code>true</code>. <code>APIFW_GRAPHQL_PLAYGROUND_PATH</code> Designates the path where the playground will be accessible. By default, it is the root path <code>/</code>. <p>Once set up, you can access the playground interface from the designated path in your browser:</p> <p></p>"},{"location":"installation-guides/graphql/websocket-origin-check/","title":"WebSocket Origin Validation","text":"<p>When a browser initiates a WebSocket connection, it automatically includes an <code>Origin</code> header that denotes the domain from which the request originates. With Wallarm API Firewall, you can ensure that the value of the <code>Origin</code> header matches your predefined list during the upgrade phase of the WebSocket connection. This article outlines the steps to enable <code>Origin</code> validation for GraphQL queries.</p> <p>By default, the WebSocket Origin validation feature is disabled. To activate it, configure the following environment variables:</p> Environment variable Description <code>APIFW_GRAPHQL_WS_CHECK_ORIGIN</code> Enables the validation of the <code>Origin</code> header during the WebSocket upgrade phase. Default: <code>false</code>. <code>APIFW_GRAPHQL_WS_ORIGIN</code> (required if <code>APIFW_GRAPHQL_WS_CHECK_ORIGIN</code> is <code>true</code>) The list of allowed origins for WebSocket connections. Origins are separated by <code>;</code>. <p>The <code>APIFW_GRAPHQL_WS_CHECK_ORIGIN</code> operates independently of <code>APIFW_GRAPHQL_REQUEST_VALIDATION</code>. WebSocket requests with incorrect <code>Origin</code> headers will be blocked regardless of the request validation mode.</p>"},{"location":"migrating/modse%D1%81-to-apif/","title":"Migrating to API Firewall from ModSecurity","text":"<p>This guide walks through migrating from ModSecurity to Wallarm's API Firewall by explaining how to import the ModSecurity rules to API Firewall and set API Firewall to perform protection in accordance with these rules.</p>"},{"location":"migrating/modse%D1%81-to-apif/#problem-and-solution","title":"Problem and solution","text":"<p>In August 2021, Trustwave announced the end-of-sale for ModSecurity support, and the subsequent end-of-life date for their support of ModSecurity of July 2024. Trustwave has been providing regular updates to the standard rules for ModSecurity, supporting what was effectively an open source community tool with commercial quality detection rules. Reaching the end-of-life date and support ending may quickly put any organizations using ModSecurity rules at risk by quickly becoming out-of-date with their attack detection.</p> <p>Wallarm supports easy transitioning from ModSecurity to Wallarm's API Firewall: ModSecurity rules can be effortlessly connected to API Firewall and continued to be used without additional configuration.</p>"},{"location":"migrating/modse%D1%81-to-apif/#modsecurity-rules-support","title":"ModSecurity rules support","text":"<p>API Firewall's ModSecurity Rules Support module allows parsing and applying ModSecurity rules (secLang) to the traffic. The module is implemented using the Coraza project.</p> <p>The module works for REST API both in the API and PROXY modes. In the API mode, only requests are checked.</p> <p>Supported response actions: </p> <ul> <li> <p><code>drop</code>, <code>deny</code> - respond to the client by error message with APIFW_CUSTOM_BLOCK_STATUS_CODE code or status value (if configured in the rule).</p> </li> <li> <p><code>redirect</code> - responds by status code and target which were specified in the rule.</p> </li> </ul> <p>GraphQL API is currently not supported.</p>"},{"location":"migrating/modse%D1%81-to-apif/#running-api-firewall-on-modsecurity-rules","title":"Running API Firewall on ModSecurity rules","text":"<p>Check the demo on running API Firewall with OWASP CoreRuleSet v4.x.x</p>"}]}